---
title: 正则表达式入门
search: exclude
---

# 正则表达式入门

[《正则表达式30分钟入门教程》](http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html)的学习整理，点击标题链接查看原文。

## 入门

如果要查找一篇引文小说中的“hi”，可以使用正则表达式`hi`，或者使用忽略大小写的选项，以同时能够匹配到`hi,HI,Hi,hI`这四种情况的任意一种。但是如果“hi”包含在一个单词中，比如“history，him”等，如果需要精确查找“hi”这个单词时，则需要使用`\bhi\b`。

`\b`是正则表达式中规定的特殊字符，或称为元字符，表示单词的分界处。但是引文单词通常是由空格、换行、标点符号分割，但是`\b`并不能匹配这些，它只匹配一个位置。

如果要找的是“hi”后面不远处还有一个“Lucy”，可以使用`\bhi\b.*\bLucy\b`。

这里的`.`符号是另一个元字符，用于匹配除换行符意外的任意字符。`*`同样是元字符，它代表的是数量，它表示`*`前面的内容可以连续重复使用任意次，以使整个表达式得到匹配。因此，`.*`连在一起，表示任意数量的不包含换行的字符。现在，`\bhi\b.*\bLucy\b`的意思就很明显了：先是单词“hi”，然后是任意个任意字符（不包括换行），最后是“Lucy”这个单词。

同时使用多个元字符，可以构造出强大的表达式，比如`0\d\d-\d\d\d\d\d\d\d\d`，用于匹配一个字符串：以0开头，然后是两个数字，一个连字号“-”，后跟8个数字，也就是中国的电话号码。

这里的`\d`是另外一个元字符，匹配一位数字，而“-”并不是元字符，它只匹配本身。同时上面的例子可以简写成`0\d{2}-\d{8}`，`\d`后跟的`{8}`表示该`\d`必须重复的次数。

## 元字符

上面已经提到了几个元字符：`\b, ., *, \d`，另外`\s`匹配任意的空白符，包括空格，制表(Tab)，换行，中文全角空格等。

另一些例子：

`\ba\w*\b`匹配以字母“a”开头的单词：首先是一个单词的开始处`\b`，然后是字母“a”，然后是任意数量的字母或数字`\w*`，最后是单词的结尾`\b`。

`\d+`匹配一个或更多连续的数字。`+`和`*`是类似的元字符，不同在于`*`重复任意次(可以是0次)，而`+`重复1次或更多次。

`\b\w{6}\b`匹配6个字母的单词。

常用的元字符：

| 代码        | 说明          |
| :--------- |:------------- |
| `.`     | 匹配除换行符以外的任意字符        |
| `\w`     | 匹配字母、数字、下划线、汉字        |
| `\s`     | 匹配任意空白字符        |
| `\d`     |匹配数字        |
| `\b`     | 匹配单词的开始或结束        |
| `^`     | 匹配字符串的开始        |
| `$`     | 匹配字符串的结束        |

元字符`^`和`$`都是匹配一个位置，这和`\b`有点类似。其中，`^`用于匹配要查找的字符串的开头，`$`匹配结尾。这在验证输入时非常有用，比如验证QQ必须是5到12位的数字时：`^\d{5,12}$`。

`{5，12}`表示重复的次数，最少不能低于5次，最多不能超过12次。

因为同时使用了`^`和`$`，所以输入的整个字符串都要和`\d{5,12}`来匹配，也就是说整个输入必须是5到12个数字。

和忽略大小写的选项类似，有些正则工具还有一个处理多行的选项。如果开启该选项，则`^`和`$`的意义就变成了：匹配行的开始和结尾处。

## 字符转义

如果想要匹配元字符本省，比如查找“.”或者“*”字符，需要使用反斜杠“\”进行转义，比如`\.`或`*`，`\\`用于匹配“\”字符本身。

## 重复

像上面提到的一些重复方式：`*`，`+`，`{2}`，`{5，12}`，下面是所有的重复限定符：

| 代码        | 说明          |
| :--------- |:------------- |
| `*`     | 重复0次或更多次       |
| `+`     | 重复1次或更多次        |
| `?`     | 重复1次或0次        |
| `{n}`     | 重复n次        |
| `{n,}`     | 重复n次或更多次        |
| `{n,m}`     | 重复n到m次        |

`Windows\d+`匹配“Windows”后面跟一个或多个数字。
`^\w+`匹配一行的第一个单词。

## 反义

有时候需要查找不属于某个简单定义的字符类的字符。可以使用反义。

常用的反义代码：

| 代码        | 说明          |
| :--------- |:------------- |
| `\W`     | 匹配任意不是字母、数字、下划线、汉字的字符       |
| `\S`     | 匹配任意不是空白符的字符        |
| `\D`     | 匹配任意非数字的字符        |
| `\B`     | 匹配不是单词开头或结尾的位置        |
| `[^x]`     | 匹配除了“x”以外的任意字符        |
| `[^aeiou]`     | 匹配除了“aeiou”几个字母之外的任意字符        |

`\S+`匹配不包含空白符的字符串。
`<a[^>]+>`匹配用尖括号括起来的以“a”开头的字符串。

## 后向引用

使用小括号指定一个自表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其他程序中做进一步的处理。默认情况下，每个分组会自动获取一个组号，规则是：从左到右，以分组的坐括号为组号，依次为1，2，3..递增。

**后向引用** 用于重复搜索前面某个分组匹配的文本。比如，`\1`代表分组1匹配的文本。

`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像“go go”或“kitty kitty”。这个表达式首先是一个单词，也就是，单词开始处和结尾处之间的多余一个的字母或数字(`\b(\w+)\b`)，这个单词会被捕获到编号为1的分组中，然后是一个或多个空白符，最后是 分组1中捕获的内容(也就是前面捕获的那个单词)(`\1`)。

即：匹配一个单词后将它放入一个编号为1的分组，间隔一个或多个空白符后，通过`\1`的内容再次进行匹配后续的内容，以匹配像“go go”这样的字符串。

同时也可以自己指定自表达式的 **组名** 。通过尖括号或者单引号“'”指定：`?<Word>\w+`或`?'Word'\w+`，把`\w+`的组号指定为“Word”。要反向引用这个分组捕获的内容，可以使用`\k<Word>`，所以上一个例子可以改写为`\b(?<Word>\w+)\b\s+\k<Word>\b`。

小括号还有一些其他特定用途，常见的分组语法：

| 分类        | 代码/语法     |  说明    |
| :--------- |:------------- | :------------ |
| 捕获     | (exp)        | 匹配exp，并捕获文本到自动命名的组里    |
| 捕获     | (?<name>exp)        | 匹配exp，并捕获文本到名称为name的组里，也可以改写成(?'name'exp)    |
| 捕获     | (?:exp)        | 匹配exp，不捕获匹配的文本，也不给此分组分配组号    |
| 零宽断言     |(?=exp)        | 匹配exp前面的位置    |
| 零宽断言     | (?<=exp)        | 匹配exp后面的位置    |
| 零宽断言     | (?!exp)        | 匹配后面跟的不是exp的位置    |
| 零宽断言     | (?<!exp)        | 匹配前面不是exp的位置    |
| 注释     | (?#comment)        | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读    |

已经讨论过前两种语法，第三个`(?:exp)`不会改变正则表达式的处理方式，只是这样的组匹配的内容：不会像前两种那样被捕获到某个组里，也不会拥有组号。

## 领宽断言

上面的图表中领宽断言部分，它们像`\b`、`^`、`$`那样用于指定一个位置，这个位置应该满足一定的条件，即断言，因此也称为 **零宽断言** 。

`(?=exp)`也叫 **零宽度正预测先行断言** ，它 断言自身出现的位置后面部分能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以”ing“结尾的单词的前面部分(即除了ing以外的部分)，用它来查找”I'm singing while you're dancing.“时会匹配到”sing“和”danc“。

`(?<=exp)`也叫 **零宽度后回顾后发断言** ，它 断言自身出现的位置的前面部分能匹配exp。比如`(?<=\bre)\w+\b`会匹配：以”re“开头的单词的后半部分(除了re以外的部分)，查找”reading a book“时会匹配到”ading“。

如果想要给一个很长的数字中没三位间加一个逗号(从右边加起)，可以这样查找需要在前面和里面需要添加逗号的部分：`((?<=\d)\d{3})+\b`，查找1234567890时会得到234567890。

一个同时使用两种断言的例子：`(?<=\s)\d(?=\s)`，匹配：以空白符间隔的数字，不包括这些空白符。

## 负向零宽断言

前面讨论过如何查找 **不是某个字符或不在某个字符串里** 的字符串的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不像去匹配它时怎么办呢？比如，我们想要查找单词，它里面出现了字母q，但是q后面跟的不是u我们可以尝试这样：`\b\w*q[^u]\w*\b`，匹配一个包含字母q，而q后面跟的又不是u的单词。

但是如果多测试会发现，如果q是单词结尾的话，像”Iraq，Benq“，该表达式就是失效。这是因为`[^u]`总要匹配一个字符，所有如果q是单词结尾字符的话，后面的`[^u]`将会匹配后面的单词分割符，后面的`\w*\b`将会匹配下一个单词，于是`\b\w*q[^u]\w*\b`就能匹配整个”Iraq fighting“。**负向领宽断言** 能够解决这个问题，因为它只匹配一个位置，而不消费任何字符，因此可以使用`\b\w*q(?!u)\w*\b`。

**零宽度负预测先行断言** `(?!exp)`，断言此位置的后面的位置不能匹配表达式exp。比如：`\d{3}(?!\d)`匹配三位数字，而且这个三位数字的后面不能是数字。`\b((?!abc)\w)+\b`匹配不包含连续字符串”abc“的单词。

同样，可以使用`(?<!exp)`，零宽度负回顾后发断言 来断言此位置的前面不能匹配表达式exp。`(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

一个更复杂的例子：`(?<=<(\w+)>).*(?=<\/\1>)`，匹配包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)`指定了这样的前缀：被尖括号括起来的单词(比如`<b>`)，然后是`.*`(任意字符串)，最后一个是后缀`(?=<\/\1>)`。注意后缀中的`\/\`是字符转义。`\1`则是一个反向引用，引用的正式捕获的第一组，前面的`(\w+)`匹配的内容，这样如果前缀定义的是<b>的话，后缀就是</b>了，整个表达式匹配的是<b>和</b>之间的内容(不包括前缀和后缀本身)。

## 注释

小括号的另一种用途是通过语法`(?#comment)`来包含注释，例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。

要包含注释的话，最好启用”忽略模式中的空白符“选项。这样在编写表达式时能任意添加空格、Tab、换行，在使用时这些都会被忽略。启用该选项后，在#后面到这一行结束的所有文本都会被当成注释忽略掉。比如可以写成这样：

	(?<=    # 断言要匹配的文本的前缀
      <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )       # 前缀结束
      .*      # 匹配任意文本
      (?=     # 断言要匹配的文本的后缀
      <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )       # 后缀结束

## 贪婪与懒惰

如果表达式中包含重复限定符时，通常是(在使整个表达式能得到匹配的前提下)匹配尽可能多的字符。比如`a.*b`，它将会匹配，最长的以a开始，以b结束的字符串。如果用它搜索”aabab“将会匹配整个字符串。称为 **贪婪匹配** 。

有时需要 **懒惰匹配** ，也就是匹配尽可能少的字符。前面给出的限定符都能转化为懒惰模式，只要在前面加一个问号`?`。`.*?`表示匹配任意数量的重复，但是在能使整个表达式匹配成功的前提下使用尽量少的重复。再次搜索上面的字符串，将会得到aab和ab。

懒惰限定符：

| 代码/语法        | 说明          |
| :--------- |:------------- |
| `*?`     | 重复任意次，但是尽可能少的重复      |
| `+?`     | 重复1次或更多次，但是尽可能少的重复        |
| `??`     | 重复0次或1次，但是尽可能少的重复        |
| `{n,m}`     | 重复n到m次，但是尽可能少的重复        |
| `{n,}`     | 重复n次以上，但是尽可能少的重复        |

## 处理选项

已经介绍过忽略大小写、处理多行等，这些选项用来改变处理正则表达式的方式。

.Net中常用的正则表达式选项：

| 名称        | 说明          |
| :--------- |:------------- |
| IgnoreCase(忽略大小写)     | 匹配时不区分大小写      |
| Multiline(多行模式)     | `^`和`$`在行首和行尾匹配，而不是字符串的开头和结尾   |
| Singleline(单行模式)     | 更改`.`的含义，使他与每个字符匹配，包括换行符`\n`        |
| IgnorePatternWhitespace(忽略空白)     | 忽略表达式中的非转义空白并启用由`#`标记的注释        |
| ExplicitCapture(显式捕获)     | 仅捕获已被显式命名的组        |

单行模式与多行模式并无关联，可以同时使用。

## 平衡组/递归匹配

有时需要匹配像“(100 * (50 + 15))”这样嵌套的层次结构，使用`\(.+\)`则只会匹配到最左边的左括号和最右边的右括号之间的内容。这种格式如何进行配对呢？

为了避免`(`和`\(`的混淆，这里我们可以使用尖括号。

这里需要用到一下的语法结构：

1. `(?'group')` 把捕获的内容命名为group，并压入堆栈
2. `(?'-group')` 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈原来为空，则本分组的匹配失败
3. `(?(group)yes|no)` 如果堆栈上存在的名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
4. `(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

我们需要做的就是每碰到左括号，就在压入一个“Open”，每碰到一个右括号，就弹出一个，到最后就看看堆栈是否为空，如果不为空就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面的货最后面的一些字符)，尽量使整个表达式得到匹配。

	<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦的"Open"；如果还有，则匹配失败

	>                         #最外层的右括号

平衡组的一个最常见的应用就是匹配HTML，下面这个例子可以匹配嵌套的“div”标签：`<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>` 。

## 其他

其他尚未详细讨论的语法：

| 代码/语法        | 说明          |
| :--------- |:------------- |
| `\a`     | 报警字符      |
| `\b`     | 通常是单词分界位置，但如果在字符类里使用代表退格        |
| `\t`     | Tab制表符        |
| `\r`     | 回车        |
| `\v`     | 竖向制表符        |
| `\f`     | 换页符        |
| `\n`     | 换行符        |
| `\e`     | Escape        |
| `\0nn`     | ASCII代码中八进制代码为nn的字符        |
| `\xnn`     | ASCII代码中十六进制代码为nn的字符        |
| `\unnn`     | Unicode代码中十六进制为nnnn的字符       |
| `\cN`     | ASCII控制字符。比如\cC代表Ctrl+c        |
| `\A`     | 字符串开头，类似`^`，但不受处理多行选项的影响        |
| `\Z`     | 字符串结尾或行尾，不受多行处理选项的影响        |
| `\z`     | 字符串结尾，类似`$`，但不受处理多行选项的影响        |
| `\G`     | 当前搜索的开头        |
| `\p{name}`     | Unicode中命名为name的字符类，例如`\p{IsGreek}`        |
| `(?>exp)`     | 贪婪子表达式        |
| `(?<x>-<y>exp)`     | 平衡组        |
| `(?im-nsx:exp)`     | 在子表达式exp中改变处理选项        |
| `(?im-nsx)`     | 为表达式后面的部分改变处理选项        |
| `(?(exp)yes|no)`     | 把exp当做零宽正向先行断言，如果这个位置能够匹配，使用yes作为此组的表达式，否则使用no        |
| `(?(exp)yes)`     | 同上，只是使用空表达式作为no        |
| `?(name)yes|no)`     | 如果命名为name的组捕获到了内容，使用yes作为表达式，否则使用no        |
| `?(name)yes)`     | 同上，只是使用空表达式作为no        |


## 常用表达式 - 1

一些常用的正则表达式：

1. 验证用户名和密码，5到15位的大小写字母、数字、下划线：`^[a-zA-Z]\w{5,15}$`
2. 验证电话号码：`^(\d{3,4}-)\d{7,8}$`
3. 验证手机号码：`^1[3|4|5|7|8[0-9]\d{8}$`
4. 验证身份证号(15-18位)：`\d{14}[[0-9],[0-9xX]]`
5. 验证Email地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\w+([-.]\w+)*$`
6. 限定数字和26个字母：`^[A-Za-z0-9]+$`
7. 整数或者小数：`[0-9]+([.]{0,1}[0-9]+){0,1}`
8. 数字：`^[0-9]*$`
9. N位数字：`^\d{n}$`
10. 至少N位数字：`^\d{n,}$`
11. M到N位数字：`^\d{m,n}$`
12. 0或非0开头的数字：`^(0|[1-9][0-9]*)$`
13. 两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`
14. 1到3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`
15. 非零正整数：`^\+?[1-9][0-9]*$`
16. 非零负整数：`^\-?[1-9][0-9]*$`
17. 长度为3的字符：`^.{3}$`
18. 26个英文字母：`^[A-Za-z]+$`
19. 包含`^%&',;=?$\`等字符：`[^%&',;=?$\x22]+`
20. 汉字：`^[\u4e00-\u9fa5]{0,}$`
21. 验证URL：`^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
22. 验证一年的12个月：`^(0?[1-9]|1[0-2])$`
23. 验证31天：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
24. 获取日期：`\d{4}[年|\-|\.]\d{1-12}[月|\-|\.]\d{1-31}?`
25. 双字节字符串：`[^\x00-\xff]`
26. 匹配空白行：`\n\s*\r`
27. HTML标记：`<(\S*?)[^>]*>.*?</>|<.*?/>`
28. 首尾空白：`^\s*|\s*$`
29. IP地址：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

## 常用表达式 - 2

1. 校验密码强度,8-10位大小写字母数字,不包含字符: `^(?=.*d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
2. 校验中文,只能包含中文: `^[u4e00-u9fa5]{0,}$`
3. 校验数字 + 26个字母 + 下划线的组合: `^w+$`
4. 校验Email地址: `[w!#$%&'*+/=?^_`{|}~-]+(?:.[w!#$%&'*+/=?^_`{|}~-]+)*@(?:[w](?:[w-]*[w])?.)+[w](?:[w-]*[w])?`
5. 校验身份证号码,15或18位: `^[1-9]d{7}((0d)|(1[0-2]))(([0|1|2]d)|3[0-1])d{3}$` 或 `^[1-9]d{5}[1-9]d{3}((0d)|(1[0-2]))(([0|1|2]d)|3[0-1])d{3}([0-9]|X)$`
6. 校验日期,`yyyy-mm-dd`格式: `^[1-9]d{5}[1-9]d{3}((0d)|(1[0-2]))(([0|1|2]d)|3[0-1])d{3}([0-9]|X)$`
7. 校验金额,精确两位小数: `^[0-9]+(.[0-9]{2})?$`
8. 校验手机号,13/15/18开头: `^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])d{8}$`
9. 判断IE版本: `^.*MSIE [5-8](?:.[0-9]+)?(?!.*Trident/[5-9].0).*$`
10. 校验IP-v4地址: `b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)b`
11. 校验IP-v6地址: `(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))`
12. 校验URL前缀,判断是`http`还是`https`: `if (!s.match(/^[a-zA-Z]+:///)) {     s = 'http://' + s; }`
13. 提取URL连接: `^(f|ht){1}(tp|tps)://([w-]+.)+[w-]+(/[w- ./?%&=]*)?`
14. 检验文件路径和扩展名: `^([a-zA-Z]:|)([^]+)*[^/:*?"<>|]+.txt(l)?$`
15. 提取`Color Hex Codes`: `^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$`
16. 提取网页图片: `< *[img][^>]*[src] *= *["']{0,1}([^"' >]*)`
17. 提取页面超链接: `(<as*(?!.*brel=)[^>]*)(href="https?://)((?!(?:(?:www.)?'.implode('|(?:www.)?', $follow_list).'))[^"]+)"((?!.*brel=)[^>]*)(?:[^>]*)>`
18. 查找CSS属性: `^s*[a-zA-Z-]+s*[:]{1}s[a-zA-Z0-9s.#]+[;]{1}`
19. 抽取注释: `<!--(.*?)-->`
20. 匹配HTML标签属性: `</?w+((s+w+(s*=s*(?:".*?"|'.*?'|[^'">s]+))?)+s*|s*)/?>`