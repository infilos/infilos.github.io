---
title: CH06-结构型-适配器
search: exclude
---

# CH06-结构型-适配器

### 模式动机

- 在软件开发中采用**类似于电源适配器的设计和编码技巧**被称为适配器模式。
- 通常，客户端可以通过目标类的接口访问他所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是现有类中方法名与目标类中定义的方法名不一致等原因导致的。
- 这时，现有的接口要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类提供的功能，适配器用于完成这些转化。
- 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类即为适配器(Adapter)，他所包装的对象就是适配者(Adaptee)，即被适配的类。
- 适配器提供客户类需要的接口，适配器的实现就是**把客户类的请求转化为对适配者的相应接口调用**。也就是说：**当客户类调用适配器的方法时，在适配器的内部将调用适配者的方法，而这个过程对客户端是透明的，客户端并不直接访问适配者类**。因此，适配器可以使因为接口不兼容而不能交互的类完成兼容。即该模式的动机。

### 模式定义

**适配器模式(Adapter Pattern)**，将一个接口转换为客户端期望的另一个接口，使接口不兼容的类可以在一起工作，别名为**包装器(Wrapper)**。该模式即可以作为类接口型模式，也可以作为对象结构型模式。

### 模式结构

包含如下角色：

- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类

### 类图

分为**对象适配器**和**类适配器**两种实现：

#### 对象适配器

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134456.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

#### 类适配器

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134512.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 时序图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134528.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 代码分析

对象适配器：

```c++
int main(int argc, char *argv[]){
  Adaptee * adaptee = new Adaptee();
  Target * target = new Adapter(adaptee);
  target->request();
  return 0;
}
```

### 优点

- 将目标类与适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无需修改原有代码；
- 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端来说是透明的，而且提高了适配者的复用性。
- 灵活性和扩展性很好，通过使用配置文件，可以方便的更换适配器，也可以在不修改原有代码的基础上增加的的适配器类，完全符合“开闭原则”。

类适配器模式的独特优点：

​	**由于适配器类是适配者类的子类**，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。

对象适配器模式的独特优点：

​	一个对象适配器可以把多个不同的适配者适配到同一目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

### 缺点

- 类适配器的缺点：对于 Java、C# 等不支持多重继承的语言，一次只能适配一个适配者类，而且目标类只能为抽象类，不能为具体类，有一定局限性，不能将一个适配者类和其子类都适配到目标接口。
- 对象适配器的缺点：对类适配器相比，要想置换适配者类的方法不方便。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后把这个子类当做真正的适配者进行适配，实现复杂。

### 适用场景

- 需要使用现有类，而这些类的接口不符合系统的需要。
- 想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。

### 模式扩展

**默认适配器模式(Default Adapter Pattern)**，或称缺省适配器模式。当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，该抽象类的子类则可以有选择的覆盖父类的某些方法来实现需求。适用于一个接口不想使用其所有的方法的情况，因此也称为单接口适配器模式。

