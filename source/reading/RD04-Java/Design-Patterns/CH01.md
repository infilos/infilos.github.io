---
title: CH01-创建型-简单工厂
search: exclude
---

# CH01-创建型-简单工厂

## 创建型模式概述

创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道他们的共同接口，而不清楚其具体细节，使整个系统的设计更加符合单一职责原则。

该模式在创建什么(what)、由谁创建(who)、何时创建(when)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

## 简单工厂(Simple Factory Pattern)

### 模式动机

比如一个软件系统可以提供多个外观不同的按钮(圆形、矩形、菱形等)，这些按钮都源自同一个基类，在继承基类后不同的子类修改了部分属性从而使得他们可以呈现不同的外观，如我们在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把参数传入该方法即可返回一个相应的按钮对象，这时就可以使用该模式。

### 模式定义

又称为**静态工厂方法(Static Factory Method)**，它属于类创建型模式。该模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，这些被创建的实例通常拥有共同的父类。

### 模式结构

简单工厂模式包含如下角色：

- Factory：工厂角色

  负责实现创建所有实例的内部逻辑。

- Produce：抽象产品角色

  是创建的所有对象的父类，负责描述所有实例所共有的公共接口

- ConcreteProduce：具体产品角色

  是创建目标，所有创建的对象多充当这个角色某个具体类的实例


### 类图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220133908.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>


### 时序图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220133938.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 代码实例

#### C++

```c++
#include "Factory.h"
#include "ConcreteProductA.h"
#include "ConcreteProductB.h"
Product* Factory::createProduct(string proname){
	if ( "A" == proname )
	{
		return new ConcreteProductA();
	}
	else if("B" == proname)
	{
		return new ConcreteProductB();
	}
	return  NULL;
}
```

### 模式分析

- 将**对象的创建**和**对象的业务处理**分离可以降低系统的耦合度，使得两者修改起来更简便。
- 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用方便，可通过类名直接调用，而且只需要传入一个简单的参数即可。在实际开发中，还可以在调用时将所传入的参数保存在 XML 等配置文件中，修改参数时无需修改任何源代码。
- 该模式最大的问题在于工厂类的职责过重，增加新的产品需要修改工厂类的逻辑判断，这一点与**开闭原则**是相违背的。
- 该模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获得你需要的对象，而无需知道其创建细节。

### 优点

- 工厂类含有必要的逻辑判断，可以决定什么时候(条件)创建什么类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”(使用)产品。通过这种方式实现对责任的分割，提供专门的工厂类用于创建对象。
- 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类对应的参数即可，对于一些复杂的类名，通过该模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换个增加新的产品类，在一定程度上提高了系统的灵活性。

### 缺点

- 由于工厂类中集中了所有产品类的创建逻辑，一旦不能正常工作，将影响整个系统。
- 该模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和立即难度。
- 系统扩展困难，一旦添加新的产品类则必须修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑较为复杂，不利于系统的扩展和维护。
- 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 适用场景

- 工厂类负责创建的对象比较少：由于创建的对象类别少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，也不需要知道类名，只需要知道该类型需要的参数。

### 模式应用

1. JDK 类库中广泛使用了该模式，如工具类`java.text.DateFormat`，用于格式化一个本地日期：

   ```java
   public final static DateFormat getDateInstance();
   public final static DateFormat getDateInstance(int style);
   public final static DateFormat getDateInstance(int style, Local local);
   ```

2. Java 加密技术：

   1. 获取不同加密算法的密钥生成器：

      ```java
      KeyGenerator keyGen = KeyGenerator.getInstance("DESede");
      ```

   2. 创建密码器：

      ```java
      Cipher cp = Cipher.getInstance("DESede");
      ```

### 总结

- 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用分离。
- 简单工厂模式又称为静态工厂方法模式，属于类创建型模式。在该模式中，可以根据参数的不同返回不同类的实例。同时专门定义了一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
- 包含三个角色：**工厂角色**负责实现创建所有实例的内部逻辑；**抽象产品角色**是需要创建的所有类的父类，负责描述所有实例所共有的公共接口；**具体产品角色**是创建目标，所有创建的对象都充当这个角色某个具体类的实例。
- 要点在于：当你需要什么，只需要传入对应正确的参数，就可以获得对应的对象，而无需知道创建细节。
- 有点在于：将对象的创建与使用分离，将对象的创建交给工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品则需要修改工厂的判断逻辑，当产品较多时，逻辑将会复杂。
- 适用场景：工厂类需要创建的对象比较少；客户端只知道传入工厂类的参数，对于创建过程不关心。