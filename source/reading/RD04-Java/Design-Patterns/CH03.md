---
title: CH03-创建型-抽象工厂
search: exclude
---

# CH03-创建型-抽象工厂

### 模式动机

- 在工厂方法模式中，具体工厂负责生成具体的产品，每个具体工厂对应一个具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或一组重载的工厂方法。但是有些时候我们需要一个工厂能够提供多个产品对象，而不是一个单一的产品对象。

  为了清晰理解工厂方法模式，需要知道两个概念：

  1. **产品等级结构**：产品等级结构即产品的继承结构（如一个抽象类是电视机，其子类有：海尔、海信、TCL等，抽象电视机与对应品牌的电视机即构成了产品等级结构）。
  2. **产品族**：在抽象工厂模式中，产品族是指**由一个工厂生产的，位于不同产品等级结构中的一组产品**。如海尔电器工厂生产的电视机、电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

- 当系统提供的工厂需要生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中、属于不同类型的具体产品时，需要使用抽象工厂模式。

- 该模式是所有形式的工厂模式中最为抽象和最具一般性的形态。

- 抽象工厂模式与工厂方法模式最大的区别在于：工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构，可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构(海尔电器工厂)，可以创建出分属不同产品等级结构的 一个产品族中的所有对象(电视机、电冰箱)时，抽象工厂模式比工厂方法模式更有效率。

### 模式定义

抽象工厂模式(Abstract Factory Pattern)：提供一个 创建一系列相关或相互依赖对象 的接口，而无需指定他们的具体类。又称为 Kit 模式。

### 模式结构

包含如下角色：

- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品

### 类图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134229.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

解释：

- AbstractFactory 可以理解为 电器工厂；
- ConcreteFactory1 可以理解为 海尔电器工厂；
- ConcreteFactory2 可以理解为 格力电器工厂；
- AbstractProductA 理解为产品 电视机；
- AbstractProductB 理解为产品 电冰箱；
- ProductA1 则为 海尔牌电视机；
- ProductA2 则为 格力牌电视机；
- ProductB1 则为 海尔牌电冰箱；
- ProductB2 则为 格力牌电视机；

因此，海尔电器工厂 可以生产 海尔牌的电视机和电冰箱，同理格力电器工厂。这样，产品等级结构(电视机、电冰箱)和产品族(海尔牌、格力牌)通过两种维度实现对产品的建模。

### 时序图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134250.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 优点

- 抽象工厂模式隔离了具体类的生产，使得客户端并不知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以从某种程度上改变整个系统的行为。同时该模式可以实现**高内聚低耦合**的实际目的，因此该模式被广泛应用。
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
- 增加新的具体工厂和产品族非常方便，无需修改已有系统，符合**开闭原则**。

### 缺点

- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就要对该接口进行扩展，这会涉及到对抽象工厂角色及其所有子类进行修改，会带来较大不便。
- 开闭原则的倾斜性，增加新的工厂和产品族容易，增加新的产品等级结构麻烦。

### 适用场景

- 当一个系统不需要依赖于产品类实例如何被创建、组合、表达的细节，这对于所有形式的工厂模式都是重要的。
- 系统中有多于一个的产品族，而每次只适用其中一个产品族。
- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
- 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。

### 模式应用

比如一些软件系统中需要更换系统主题，要求界面中的按钮、文本框、背景等一起发生改变时，就可以使用该模式。比如：按钮元素的不同形式构成一个产品等级结构，不同元素的同一主题形式构成一个产品族。

### 模式扩展

**开闭原则**的倾斜性：

- 开闭原则要求对系统扩展开发，对修改关闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强则包括两方面：
  1. 增加产品族：对于增加新的产品族，本模式很好的支持了开闭原则，只需要增加一个新的具体工厂即可，对已有代码无需做任何修改；
  2. 增加产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生成新产品的方法，不能很好的支持开闭原则。
- 抽象工厂模式的这种性质称为**开闭原则的倾斜性**，该模式以一种倾斜的方式来支持增加新的产品，为新产品族的增加提供方便，但不能为新的产品等级结构增加提供方便。

工厂模式退化：

- 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，该模式也就退化成了工厂方法模式；
- 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建产品的方法设计为静态方法时，工厂方法模式退化成简单工厂模式。

### 总结

- 该模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体类。
- 包含四种角色。
- 是所有形式的工厂模式中最为抽象和最具一般性的一种形态。
- 主要优点是隔离了具体类的生成，使得客户端不知道什么被创建。
- 。。。

