---
title: CH04-创建型-建造者
search: exclude
---

# CH04-创建型-建造者

### 模式动机

一些复杂的对象，拥有多个组成部分，比如汽车，包括车轮、方向盘、发动机等。对于大多数用户而言，无需知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车。可以通过建造者模式对其进行设计与描述，建造者模式可以将其部件和其组装过程分开，逐步创建一个对象。用户只需要指定复杂对象的类型就可以得到该对象，而无需知道其内部的具体构造细节。

软件系统中也存在大量类似汽车的复杂对象，拥有一系列成员和属性，这些成员属性中有些是引用类型的成员对象。而且这些复杂对象中，还可能存在一些限制条件，如某些属性赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。

复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称为**建造者**的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无需关心该对象所包含的属性以及他们的组装方式，这就是建造者模式的模式动机。

### 模式定义

**建造者模式(Builder Pattern)**，将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。

该模式是逐步创建一个复杂对象，允许用户只通过指定复杂对象的类型和内容就可以构建他们，而不需要知道他们内部的具体构建细节。又称为**生成器模式**。

### 模式结构

- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

### 类图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134317.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 时序图

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134335.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 代码示例

抽象建造者：

```java
public interface PersonBuilder{
  void buildHead();
  void buildBody();
  void buildFoot();
  Persion buildPerson();
}
```

具体建造者 1：

```java
public class ManBuilder implements PersonBuilder{
  Person person;
  public ManBuilder() {
    person = new Man();
  }
  public void buildBody() {
    person.setBody("set man's body");
  }
  public void buildFoot() {
    person.setFoot("set man's foot");
  }
  public void buildHead() {
    person.setHead("set man's head");
  }
  public Person buildPerson() {
    return person;
  }
}
```

具体建造者 2：

```java
public class WomanBuilder implements PersonBuilder{
  Person person;
  public WomanBuilder() {
    person = new Woman();
  }
  public void buildBody() {
    person.setBody("set woman's body");
  }
  public void buildFoot() {
    person.setFoot("set woman's foot");
  }
  public void buildHead() {
    person.setHead("set woman's head");
  }
  public Person buildPerson() {
    return person;
  }
}
```

指挥者：

```java
public class PersonDirector {
  public Person constructPerson(PersonBuilder pb){
    pb.buildHead();
    pb.buildBody();
    pb.buildFoot();
    return pb.buildPerson();
  }
}
```

产品：

```java
public class Person {
  private String head;
  private String body;
  private String foot;
  
  public void setHead(String head){
    this.head = head;
  }
  public void setBody(String body){
    this.body = body;
  }
  public void setFoot(String foot){
    this.foot = foot;
  }
}

public class Man extends Person {
  public Man() {
    System.out.println("Start building Man");
  }
}

public class Woman extends Person {
  public Woman() {
    System.out.println("Start building Woman");
  }
}
```

用例：

```java
public class Usage{
  public static void main(String[] args){
    PersonDirector pd = new PersonDirector();
    Person manPerson = pd.constructPerson(new ManBuilder());
    Person womanPerson = pd.constructPerson(new WomanBuilder());
  }
}
```

### 模式分析

抽象建造者类中定义了产品的创建方法和返回方法。

建造者模式的结构中还引入了一个指挥者类 Director，该类作用主要有两个：一方面将客户端与产品生产过程；另一方面负责整个产品的生产过程。

指挥者针对抽象建造者编程，客户端只需要提供具体建造者的类型，即可通过指挥者来调用具体建造者的方法，返回一个完整的产品对象。

在客户端代码中，则不需要关心产品具体的生产过程，只需要提供具体建造者类型来调用指挥者的创建方法。建造者模式将复杂对象的构建与对象的表现分离开来，这使得同样的构建过程可以创建出不同的表现。

### 实例

#### KFC 套餐

套餐看做是一个复杂对象，一般包括主食(汉堡、鸡肉卷等)和饮料(果汁、可乐等)等组成部分，服务员可以根据要求，逐步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。

类图：

<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134351.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>

### 优点

- 客户端不必知道产品内部的组成细节，将产品本身与产品的创建过程解耦，使得**相同的创建过程**(由父类创建者约束了创建该过程)可以创建不同的产品对象。
- 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便的替换具体建造者或者增加新的具体建造者，**用户使用不同的具体建造者即可得到不同的产品对象。**
- **可以更加精细的控制产品的创建过程。**将复杂产品的的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
- **增加新的具体创建者无需修改原有代码，指挥者针对抽象建造者编程。**系统扩展方便，符合开闭原则。

### 缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式。
- 如果产品的内部变化复杂，可能需要定义很多具体建造者来实现这些变化，导致系统庞大。

### 适用场景

- 需要生产的产品有复杂的内部结构，产品通常包含多个成员属性。
- 需要生产的额产品，其属性相互依赖，需要制定生成顺序。
- 对象的创建过程独立于创建该对象的类。在该模式中引入了指挥者类，将创建过程封装在指挥者类中，而不再建造者中。
- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

### 模式扩展

建造者模式的简化：

- 省略掉抽象建造角色：如果系统中只需要一个具体建造者的话。
- 省略掉指挥者：在具体建造者只有一个的情况下，如果抽象建造者以及被省略掉，那么还可以省略掉指挥者，让建造者充当指挥者与建造者角色。

建造者模式与抽象工厂模式的比较：

- 建造者返回一个组装好的完整产品，抽象工厂返回一系列相关的产品，这些产品位于不同的产品等级结构，构成一个产品族。
- 抽象工厂中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象；建造者中，客户端通过指挥类而不是调用建造者的相关方法，侧重于逐步构造一个复杂对象。
- 如果将抽象工厂看做是“汽车配件生产工厂”，生产一个产品族的产品；建造者模式就是一个“汽车组装工厂”，通过对部件的组装返回一辆完整的汽车。

