---
title: SE01-Big Picture
---

# 纵观全局

Parboiled 提供了一个递归下降的 PEG 解析器实现来操作你指定的 PEG 规则。

你的语法规范可以包含解析器动作，这些动作可以在解析过程中的任意一点执行额外的逻辑，比如使用自定义条件来增强输入识别，或者构造抽象语法树(AST)。

## 两个阶段

你的代码会在两个阶段与 Parboiled 交互。在第一个阶段——“规则构造”阶段，Parboiled 会基于你定义的 Java/Scala 代码为解析器规则构建一个树(一个有向图)。该阶段与实际的输入阶段没有依赖，仅需要在整个 JVM 的生命周期中执行一次，即构建过的规则树是可复用的。第二个阶段是实际的解析阶段，使用第一阶段中的规则来处理特定的输入文本。最终的执行结构将包含以下信息：

- 一个布尔值来表示输入是否与根规则匹配。
- 可能遇到的所有解析错误。
- 由你的解析器动作构造的一个或多个值对象。

## 规则构造

在执行由 Java/Scala 定义的规则代码时将触发规则构造。Parboiled 分别为 Java 和 Scala 提供了单独的 DSL 来使得规则的定义过程与语言本身结合的更加舒适。

在 Java 中你需要实现一个自定义类来继承 BaseParser 类，并定义一些方法来返回 Rule 实例。这些方法可以通过调用其他自定义方法、终止符、预定义原语、动作表达式来构造规则实例。由于 Java 语法的限制，Parboiled 则使用了一个名为“解析器扩展(Parser Extension)”的过程来支持比其他方式更加简洁的规则构造代码。

因为 Scala 本身就富有较强的表现力，因此 Parboiled 并不需要为 Scala 再提供一个单独的解析器扩展步骤。在 Scala 中，你可以直接通过 Scala 语言元素来构造解析器规则树。

## 解析动作

为了避免你的解析器仅仅是一个“识别器”(一段仅能检测输入是否与定义的语法匹配的代码)，在你的解析器中需要包含一些动作。解析器动作是一段自定义的代码，在规则执行期间的一些特定点被执行。除了检查解析器状态(如查看匹配的输入文本片段)，解析器动作通常用于构造“值”(如 AST 节点)，并可以作为语义谓词主动影响解析过程。

## 值栈

在规则执行阶段，你的解析器动作可以利用“值栈”来组织自定义对象的构造，如 AST 节点。值栈是一个简单的栈结构，作为一个临时存储为自定义对象提供服务。使用值栈的方式取决于你使用的是 Parboiled Java 还是 Parboiled Scala。

## 解析树

在规则执行阶段 Parboiled 能够以可选的方式构造一个解析树，其节点对应于已识别的规则。每个解析树 Node 包含一个对应规则的 Matcher，同时，被匹配的输入文本(位置)也会作为当前值栈的栈顶元素。该解析树可以被看做是输入对已匹配规则的记录，在调试过程中尤其有用。

## 解析执行器

ParseRunner 的职责是“监管”解析的执行过程，并能以可选的方式提供额外的逻辑，尤其重要的是对非法输入字符的处理(基于语法)。当你使用 Parboiled 执行解析时可以选择一下 5 种预定义的 ParseRunner：

1. BasicParseRunner，最快最基本的 ParseRunner，不执行错误处理。
2. ReportingParseRunner，为输入的第一个错误创建衣蛾 InvalidInputError。
3. RecoveringParseRunner，最复杂的 ParseRunner，报告输入中的所有错误，并尝试从错误中恢复。
4. TracingParseRunner，为每条匹配的或未匹配的规则有选择的打印追踪信息。
5. ProfilingParseRunner，在你的解析器处理一个或多个输入时生成详细的统计信息。

