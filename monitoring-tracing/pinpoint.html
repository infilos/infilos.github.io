<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Pinpoint · Infilos</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Infilos'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Infilos
</a>
<div class="version-number">
1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../vm/index.html" class="page">虚拟机</a>
  <ul>
    <li><a href="../vm/java-vm/index.html" class="page">Java VM</a></li>
  </ul></li>
  <li><a href="../java-lang/index.html" class="page">Java Lang</a>
  <ul>
    <li><a href="../java-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../java-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../java-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../java-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../java-concur/index.html" class="page">Java Concurrency</a>
  <ul>
    <li><a href="../java-concur/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../scala-lang/index.html" class="page">Scala Lang</a>
  <ul>
    <li><a href="../scala-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../scala-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../scala-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../scala-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../scala-concur/index.html" class="page">Scala Concurrency</a></li>
  <li><a href="../monitoring-tracing/index.html" class="page">监控与追踪</a>
  <ul>
    <li><a href="../monitoring-tracing/google-dapper-essentials.html" class="page">Google Dapper</a></li>
    <li><a href="../monitoring-tracing/opentracing-spec.html" class="page">OpenTracing</a></li>
    <li><a href="../monitoring-tracing/zipkin/index.html" class="page">Zipkin</a></li>
    <li><a href="../monitoring-tracing/pinpoint.html" class="active page">Pinpoint</a></li>
  </ul></li>
  <li><a href="../high-performance/index.html" class="page">高性能编程</a>
  <ul>
    <li><a href="../high-performance/ipph/index.html" class="page">深入并行编程</a></li>
    <li><a href="../high-performance/seven-model/index.html" class="page">并发编程模型</a></li>
    <li><a href="../high-performance/java-thread-model/index.html" class="page">Java 并发模型</a></li>
    <li><a href="../high-performance/jc-practice/index.html" class="page">Java 并发实践</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../index.html">Infilos</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Infilos
</a>
<div class="version-number">
1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../vm/index.html" class="page">虚拟机</a>
  <ul>
    <li><a href="../vm/java-vm/index.html" class="page">Java VM</a></li>
  </ul></li>
  <li><a href="../java-lang/index.html" class="page">Java Lang</a>
  <ul>
    <li><a href="../java-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../java-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../java-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../java-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../java-concur/index.html" class="page">Java Concurrency</a>
  <ul>
    <li><a href="../java-concur/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../scala-lang/index.html" class="page">Scala Lang</a>
  <ul>
    <li><a href="../scala-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../scala-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../scala-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../scala-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../scala-concur/index.html" class="page">Scala Concurrency</a></li>
  <li><a href="../monitoring-tracing/index.html" class="page">监控与追踪</a>
  <ul>
    <li><a href="../monitoring-tracing/google-dapper-essentials.html" class="page">Google Dapper</a></li>
    <li><a href="../monitoring-tracing/opentracing-spec.html" class="page">OpenTracing</a></li>
    <li><a href="../monitoring-tracing/zipkin/index.html" class="page">Zipkin</a></li>
    <li><a href="../monitoring-tracing/pinpoint.html" class="active page">Pinpoint</a></li>
  </ul></li>
  <li><a href="../high-performance/index.html" class="page">高性能编程</a>
  <ul>
    <li><a href="../high-performance/ipph/index.html" class="page">深入并行编程</a></li>
    <li><a href="../high-performance/seven-model/index.html" class="page">并发编程模型</a></li>
    <li><a href="../high-performance/java-thread-model/index.html" class="page">Java 并发模型</a></li>
    <li><a href="../high-performance/jc-practice/index.html" class="page">Java 并发实践</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">Infilos</a></li>
  <li><a href="../monitoring-tracing/index.html">监控与追踪</a></li>
  <li>Pinpoint</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#pinpoint" name="pinpoint" class="anchor"><span class="anchor-link"></span></a>Pinpoint</h1>
<h2><a href="#分布式事务追踪" name="分布式事务追踪" class="anchor"><span class="anchor-link"></span></a>分布式事务追踪</h2>
<h3><a href="#google-dapper-中的实现" name="google-dapper-中的实现" class="anchor"><span class="anchor-link"></span></a>Google Dapper 中的实现</h3>
<p>分布式追踪系统的目的在于，当一个消息由 Node-1 发向 Node-2 时识别分布式系统中 Node-1 与 Node-2 之间的关系。</p>
<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20180920230137.png" style="display:block;width:40%;" alt="NAME" align=center />
</div>
<p>但问题在于没有办法来识别消息之间的关系。比如，我们无法发现由 Node-1 发出的 N 条消息，与被 Node-2 收到的 N&rsquo; 条消息之间的关系。换句话说，当第 X 条消息从 Node-1 发出时，在 Node-2 中收到的 N&rsquo; 条消息中，我们无法识别具体哪条才是第 X 条消息。在一些尝试中试图在 TCP 或操作系统层来追踪消息。然而，这种方式的实现复杂性极高而性能却很低，因为需要为每种协议提供独立的实现。另外，也很难精确地追踪消息。</p>
<p>然而，Google 的 Dapper 为该难题提供了一种简单的解决方案。即，在发送消息时为其添加应用层标签，从而为消息建立一种链接。比如，在 HTTP 请求中在 HTTP 首部为消息添加标签信息，然后使用这些标签来追踪消息。</p>
<p>Pinpoint 基于 Google Dapper 中的追踪技术进行建模，同时在调用方首部添加了一些应用层标签数据，以在远程调用中实现对分布式事务的追踪。这些标签信息包含一组键，它们被定义为一个 Traceid。</p>
<h3><a href="#数据结构" name="数据结构" class="anchor"><span class="anchor-link"></span></a>数据结构</h3>
<ul>
  <li>Span，RPC 追踪中的最基本单元；用于表示 RPC 到达时所完成的工作以及额外包含的追踪数据。为了保证代码级别的可见性，一个 Span 可以拥有带有标签的子 SpanEvent 作为其数据结构。而每个 Span 拥有一个 Traceid。</li>
  <li>Trace，一组拥有相同 Traceid 的、有一次 RPC 相关的所有 Span。一个 Trace 通过 Span 的 Spanid、Parentid 排序构成一个层级树结构。</li>
  <li>Traceid，一组键，包括 Txid、Spanid、Parentid。Txid 用于表示消息 ID，而 Spanid 和 Parentid 用于表示 RPC 的父子关系。</li>
  <li>Txid，基于单个事务所发出和接收到的消息的 ID。必须在所有服务节点中全局可见。</li>
  <li>Spanid，接收到 RPC 消息时所完成工作的 ID，子 RPC 抵达时生成。</li>
  <li>Parentid，生成 RPC 的 Span 被称为父 Span，即其 Spanid。如果一个节点是事务的起点，则不存在父 Span，这时我们使用 -1 作为其 Parentid 以表示这是一个 Root Span。</li>
</ul>
<h3><a href="#traceid-工作原理" name="traceid-工作原理" class="anchor"><span class="anchor-link"></span></a>Traceid 工作原理</h3>
<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20180920230201.png" style="display:block;width:80%;" alt="NAME" align=center />
</div>
<p>一个 Txid 表示三个不同的 RPC 之间互相关联，作为一个完整的事务。然而，一个 Txid 本身并不能明显的表示 RPC 之间的关系。为了识别 RPC 之间个关系，需要使用 Spanid 和 Parentid。假设这些节点是 Tomcat 服务。你可以认为一个 Spanid 是一个处理 HTTP 请求的线程。一个 Parentid 则表示发起 RPC 调用的 Span 的 Spanid。</p>
<p>Pinpoint 可以通过 Txid 发现 Span 之间的关联，并能通过 Spanid 和 Parentid 将 Span 进行排序以组成一个层级树结构。</p>
<p>Spanid 和 Parentid 都是 64 位的长整数。因为这些数字是随意生成的，可能会出现冲突问题，但对于 -9223372036854775808 到 9223372036854775807 这样的范围来说，冲突几乎不会发生。如果出现了冲突，Pinpoint 会像 Google Dapper 一样让开发者知道发生了什么，而不是在系统内部忽略冲突。</p>
<p>一个 Txid 包含一个 Agentid、JVM 启动时间、以及一个序列号：</p>
<ul>
  <li>Agentid，JVM 启动时由用户创建的 ID；必须在所有装配了 Pinpoint 的服务节点组内保持全局唯一；使其保持唯一的最简单方式就是使用主机 IP 地址，但如果需要在同一主机上运行多个 JVM 实例，则需要为主机 IP 地址添加一个后缀，以确保不重复。</li>
  <li>JVM 启动时间，需要保持一个从 0 开始的唯一序列号。该值用于确保当用户设置了重复的 Agentid 时仍然不会引起 ID 冲突。</li>
  <li>序列号，由 Pinpoint Agent 生成的 ID，从 0 开始顺序递增；会为每条消息生成一个。</li>
</ul>
<p>Dapper 和 Twitter 的分布式系统追踪平台 Zipkin 则会生成随机的 Traceid，并将冲突视为正常现象。然而，我们会尽量在 Pinpoint 避免这种冲突。因此我们提出了两个可行的选项：一种是数据的规模较小但冲突的可能性较大；另一种是数据的规模较大但冲突的可能性较低。我们更偏向于第二种。</p>
<p>或许有更好的方式来处理事务。我们提出了一些想法，比如由一个键服务器来负责生成键。但由于性能和网络错误的原因我们并未在该系统中实现。我们仍然认为批量的生成键可以作为一个备选方案。或许在未来的某些时候，这种方式会被开发出来；但是就现在来说，采用了一种简单的方法。在 Pinpoint 中，Txid 被视为是可变化的数据。</p>
<h2><a href="#字节码增强" name="字节码增强" class="anchor"><span class="anchor-link"></span></a>字节码增强</h2>
<p>前面我们介绍了分布式事务追踪。实现的一种方式是开发者自己修改他们的代码。支持开发者在创建 RPC 时添加标签信息。然而，尽管这些功能对开发者来说很有用，但更会成为开发者的负担。</p>
<p>Twitter 的 Zipkin 为了提供分布式事务追踪的功能，对库和容器(Finagle)进行了修改。然而，如果需要的话仍然需要对用户代码进行修改。我们想要在不修改代码的情况下提供这些功能，并尽可能确保代码级别的可见性。为了解决该问题，Pinpoint 中采用了字节码增强技术。Pinpoint Agent 会向创建 RPC 的部分注入代码，以实现对标签信息的自动处理。</p>
<h3><a href="#优势" name="优势" class="anchor"><span class="anchor-link"></span></a>优势</h3>
<p>有两种方式来实现分布式事务追踪。字节码增强是自动化方法的一种。</p>
<ul>
  <li>手动：开发者在用户代码的关键节点使用 Pinpoint 提供的 API 手动记录数据。</li>
  <li>自动：开发者无需进行代码修改，因为由 Pinpoint 来决定注入那些 API。</li>
</ul>
<table>
  <thead>
    <tr>
      <th>方式 </th>
      <th>优点 </th>
      <th>缺点 </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>手动 </td>
      <td>更少的开发资源、API 更简单因此 Bug 数量得以降低 </td>
      <td>开发者必须修改代码、追踪级别较低 </td>
    </tr>
    <tr>
      <td>自动 </td>
      <td>开发者无需修改代码、基于字节码能够收集更多数据 </td>
      <td>实现 Pinpoint 的成本增加、需要高级开发者来理解需要被追踪的代码并决定追踪点、复杂技术可能引入更多 Bug </td>
    </tr>
  </tbody>
</table>
<p>字节码增强是一种复杂且危险的技术。但无论如何，使用这种技术将带来很多优势。</p>
<p>尽管这需要大量的开发资源，但在应用到服务端时却几乎不需要任何资源。比如，下面对比了基于字节码增强的自动化方法与基于类库的手动方法之间对资源的消耗：</p>
<ul>
  <li>自动：总共 100</li>
  <li>Pinpoint 开发：100</li>
  <li>服务应用：0</li>
  <li>手动：总共 30</li>
  <li>Pinpoint 开发：20</li>
  <li>服务应用：10</li>
</ul>
<p>上面的对比告诉我们，手动方法的性价比更高。然而，实际的结果却大不相同，因为在 Naver，我们拥有数以千计的服务。比如，如果我们有 10 个需要修改的服务，整体消耗如下：</p>
<ul>
  <li>Pinpoint 开发 20 + 服务应用 10 * 10 个服务 = 120</li>
</ul>
<p>你会发现，对我们来说自动化方法的性价比更高。幸运的是我们拥有很多非常专业的 Java 工程师。因此，我们认为客服 Pinpoint 开发中遇到的难题只是时间问题。</p>
<h3><a href="#价值" name="价值" class="anchor"><span class="anchor-link"></span></a>价值</h3>
<p>我们选择使用字节码增强技术来实现 Pinpoint 的原因并不仅仅是上面提到的那些。</p>
<h4><a href="#隐藏-api" name="隐藏-api" class="anchor"><span class="anchor-link"></span></a>隐藏 API</h4>
<p>如果我们将 API 暴露给开发者来使用，作为 API 提供者的我们，则会被限制对 API 的修改。这种限制会给我们带来压力。</p>
<h4><a href="#易于开启-关闭" name="易于开启-关闭" class="anchor"><span class="anchor-link"></span></a>易于开启、关闭</h4>
<p>仅需在启动应用是添加、移除配置参数，即可完成对 Pinpoint 的开启关闭操作：</p>
<pre class="prettyprint"><code class="language-bash">-javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar
-Dpinpoint.agentId=&lt;Agent&#39;s UniqueId&gt;
-Dpinpoint.applicationName=&lt;The name indicating a same service (AgentId collection)&gt;
</code></pre>
<h3><a href="#原理" name="原理" class="anchor"><span class="anchor-link"></span></a>原理</h3>
<p>因为字节码增强技术应用于 Java 字节码层面，它往往会增加开发的风险并降低生产力。另外，开发人员也更易出错。在 Pinpoint 中，我们通过拦截器这种抽象来提供生产力和可访问性。Pinpoint 会在类加载的时候增强代码，以注入必要的代码来追踪分布式事务和性能信息。因为追踪代码被直接注入到了应用代码，因此对性能有所提升。</p>
<div  align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20180920230232.png" style="display:block;width:70%;" alt="NAME" align=center />
</div>
<p>在 Pinpoint 中，对 API 的拦截部分和对数据的记录部分是分离的。拦截器会被注入到我们想要追踪的方法内，而调用 <code>before()</code> 和 <code>after()</code> 则会完成对数据的记录。尽管是基于字节码增强，Pinpoint Agent 也只能从必要的方法内记录数据，从而使得要被分析的数据大小紧凑。</p>
<h2><a href="#与-zipkin-对比" name="与-zipkin-对比" class="anchor"><span class="anchor-link"></span></a>与 Zipkin 对比</h2>
<h3><a href="#差异性" name="差异性" class="anchor"><span class="anchor-link"></span></a>差异性</h3>
<p>Pinpoint 与 Zipkin 有明显的差异，主要体现在如下几个方面：</p>
<ul>
  <li>Pinpoint 是一个完整的性能监控解决方案：有从探针、收集器、存储到 Web 界面等全套体系；而 Zipkin 只侧重收集器和存储服务，虽然也有用户界面，但其功能与 Pinpoint 不可同日而语。反而 Zipkin 提供有 Query 接口，更强大的用户界面和系统集成能力，可以基于该接口二次开发实现。</li>
  <li>Zipkin 官方提供有基于 Finagle 框架（Scala 语言）的接口，而其他框架的接口由社区贡献，目前可以支持 Java、Scala、Node、Go、Python、Ruby 和 C# 等主流开发语言和框架；但是 Pinpoint 目前只有官方提供的 Java Agent 探针，其他的都在请求社区支援中（请参见 #1759 和 #1760）。</li>
  <li>Pinpoint 提供有 Java Agent 探针，通过字节码注入的方式实现调用拦截和数据收集，可以做到真正的代码无侵入，只需要在启动服务器的时候添加一些参数，就可以完成探针的部署；而 Zipkin 的 Java 接口实现 Brave，只提供了基本的操作 API，如果需要与框架或者项目集成的话，就需要手动添加配置文件或增加代码。</li>
  <li>Pinpoint 的后端存储基于 HBase，而 Zipkin 基于 Cassandra。</li>
</ul>
<h3><a href="#相似性" name="相似性" class="anchor"><span class="anchor-link"></span></a>相似性</h3>
<p>Pinpoint 与 Zipkin 都是基于 Google Dapper 的那篇论文，因此理论基础大致相同。两者都是将服务调用拆分成若干有级联关系的 Span，通过 SpanId 和 ParentSpanId 来进行调用关系的级联；最后再将整个调用链流经的所有的 Span 汇聚成一个 Trace，报告给服务端的 collector 进行收集和存储。</p>
<p>即便在这一点上，Pinpoint 所采用的概念也不完全与那篇论文一致。比如他采用 TransactionId 来取代 TraceId，而真正的 TraceId 是一个结构，里面包含了 TransactionId, SpanId 和 ParentSpanId。而且 Pinpoint 在 Span 下面又增加了一个 SpanEvent 结构，用来记录一个 Span 内部的调用细节（比如具体的方法调用等等），因此 Pinpoint 默认会比 Zipkin 记录更多的跟踪数据。但是理论上并没有限定 Span 的粒度大小，所以一个服务调用可以是一个 Span，那么每个服务中的方法调用也可以是个 Span，这样的话，其实 Brave 也可以跟踪到方法调用级别，只是具体实现并没有这样做而已。</p>
<h3><a href="#字节码注入-vs-api-调用" name="字节码注入-vs-api-调用" class="anchor"><span class="anchor-link"></span></a>字节码注入 vs API 调用</h3>
<p>根据上文所述，这一点是两者最大的差异。Pinpoint 实现了基于字节码注入的 Java Agent 探针，而 Zipkin 的 Brave 框架仅仅提供了应用层面的 API，但是细想问题远不那么简单。字节码注入是一种简单粗暴的解决方案，理论上来说无论任何方法调用，都可以通过注入代码的方式实现拦截，也就是说没有实现不了的，只有不会实现的。但 Brave 则不同，其提供的应用层面的 API 还需要框架底层驱动的支持，才能实现拦截。比如，MySQL 的 JDBC 驱动，就提供有注入 interceptor 的方法，因此只需要实现 StatementInterceptor 接口，并在 Connection String 中进行配置，就可以很简单的实现相关拦截；而与此相对的，低版本的 MongoDB 的驱动或者是 Spring Data MongoDB 的实现就没有如此接口，想要实现拦截查询语句的功能，就比较困难。</p>
<p>因此在这一点上，Brave 是硬伤，无论使用字节码注入多么困难，但至少也是可以实现的，但是 Brave 却有无从下手的可能，而且是否可以注入，能够多大程度上注入，更多的取决于框架的 API 而不是自身的能力。</p>
<h3><a href="#难度及成本" name="难度及成本" class="anchor"><span class="anchor-link"></span></a>难度及成本</h3>
<p>经过简单阅读 Pinpoint 和 Brave 插件的代码，可以发现两者的实现难度有天壤之别。在都没有任何开发文档支撑的前提下，Brave 比 Pinpoint 更容易上手。Brave 的代码量很少，核心功能都集中在 brave-core 这个模块下，一个中等水平的开发人员，可以在一天之内读懂其内容，并且能对 API 的结构有非常清晰的认识。</p>
<p>Pinpoint 的代码封装也是非常好的，尤其是针对字节码注入的上层 API 的封装非常出色，但是这依然要求阅读人员对字节码注入多少有一些了解，虽然其用于注入代码的核心 API 并不多，但要想了解透彻，恐怕还得深入 Agent 的相关代码，比如很难一目了然的理解 addInterceptor 和 addScopedInterceptor 的区别，而这两个方法就是位于 Agent 的有关类型中。</p>
<p>因为 Brave 的注入需要依赖底层框架提供相关接口，因此并不需要对框架有一个全面的了解，只需要知道能在什么地方注入，能够在注入的时候取得什么数据就可以了。就像上面的例子，我们根本不需要知道 MySQL 的 JDBC Driver 是如何实现的也可以做到拦截 SQL 的能力。但是 Pinpoint 就不然，因为 Pinpoint 几乎可以在任何地方注入任何代码，这需要开发人员对所需注入的库的代码实现有非常深入的了解，通过查看其 MySQL 和 Http Client 插件的实现就可以洞察这一点，当然这也从另外一个层面说明 Pinpoint 的能力确实可以非常强大，而且其默认实现的很多插件已经做到了非常细粒度的拦截。</p>
<p>针对底层框架没有公开 API 的时候，其实 Brave 也并不完全无计可施，我们可以采取 AOP 的方式，一样能够将相关拦截注入到指定的代码中，而且显然 AOP 的应用要比字节码注入简单很多。</p>
<p>以上这些直接关系到实现一个监控的成本，在 Pinpoint 的官方技术文档中，给出了一个参考数据。如果对一个系统集成的话，那么用于开发 Pinpoint 插件的成本是 100，将此插件集成入系统的成本是 0；但对于 Brave，插件开发的成本只有 20，而集成成本是 10。从这一点上可以看出官方给出的成本参考数据是 5:1。但是官方又强调了，如果有 10 个系统需要集成的话，那么总成本就是 10 * 10 + 20 = 120，就超出了 Pinpoint 的开发成本 100，而且需要集成的服务越多，这个差距就越大。</p>
<h3><a href="#通用性和扩展性" name="通用性和扩展性" class="anchor"><span class="anchor-link"></span></a>通用性和扩展性</h3>
<p>很显然，这一点上 Pinpoint 完全处于劣势，从社区所开发出来的集成接口就可见一斑。</p>
<p>Pinpoint 的数据接口缺乏文档，而且也不太标准（参考论坛讨论帖），需要阅读很多代码才可能实现一个自己的探针（比如 Node 的或者 PHP 的）。而且团队为了性能考虑使用了 Thrift 作为数据传输协议标准，比起 HTTP 和 JSON 而言难度增加了不少。</p>
<h3><a href="#社区支持" name="社区支持" class="anchor"><span class="anchor-link"></span></a>社区支持</h3>
<p>这一点也不必多说，Zipkin 由 Twitter 开发，可以算得上是明星团队，而 Naver 的团队只是一个默默无闻的小团队（从 <a href="https://github.com/naver/pinpoint/issues/1759">#1759</a> 的讨论中可以看出）。虽然说这个项目在短期内不太可能消失或停止更新，但毕竟不如前者用起来更加放心。而且没有更多社区开发出来的插件，让 Pinpoint 只依靠团队自身的力量完成诸多框架的集成实属困难，而且他们目前的工作重点依然是在提升性能和稳定性上。</p>
<h3><a href="#其他" name="其他" class="anchor"><span class="anchor-link"></span></a>其他</h3>
<p>Pinpoint 在实现之初就考虑到了性能问题，<a href="http://www.naver.com/">www.naver.com</a> 网站的后端某些服务每天要处理超过 200 亿次的请求，因此他们会选择 Thrift 的二进制变长编码格式、而且使用 UDP 作为传输链路，同时在传递常量的时候也尽量使用数据参考字典，传递一个数字而不是直接传递字符串等等。这些优化也增加了系统的复杂度：包括使用 Thrift 接口的难度、UDP 数据传输的问题、以及数据常量字典的注册问题等等。</p>
<p>相比之下，Zipkin 使用熟悉的 Restful 接口加 JSON，几乎没有任何学习成本和集成难度，只要知道数据传输结构，就可以轻易的为一个新的框架开发出相应的接口。</p>
<p>另外 Pinpoint 缺乏针对请求的采样能力，显然在大流量的生产环境下，不太可能将所有的请求全部记录，这就要求对请求进行采样，以决定什么样的请求是我需要记录的。Pinpoint 和 Brave 都支持采样百分比，也就是百分之多少的请求会被记录下来。但是，除此之外 Brave 还提供了 Sampler 接口，可以自定义采样策略，尤其是当进行 A/B 测试的时候，这样的功能就非常有意义了。</p>
<h3><a href="#总结" name="总结" class="anchor"><span class="anchor-link"></span></a>总结</h3>
<p>从短期目标来看，Pinpoint 确实具有压倒性的优势：无需对项目代码进行任何改动就可以部署探针、追踪数据细粒化到方法调用级别、功能强大的用户界面以及几乎比较全面的 Java 框架支持。但是长远来看，学习 Pinpoint 的开发接口，以及未来为不同的框架实现接口的成本都还是个未知数。相反，掌握 Brave 就相对容易，而且 Zipkin 的社区更加强大，更有可能在未来开发出更多的接口。在最坏的情况下，我们也可以自己通过 AOP 的方式添加适合于我们自己的监控代码，而并不需要引入太多的新技术和新概念。而且在未来业务发生变化的时候，Pinpoint 官方提供的报表是否能满足要求也不好说，增加新的报表也会带来不可以预测的工作难度和工作量。</p>
<h2><a href="#reference" name="reference" class="anchor"><span class="anchor-link"></span></a>Reference</h2>
<ul>
  <li><a href="http://naver.github.io/pinpoint/">Pinpoint</a></li>
  <li><a href="http://www.tangrui.net/2016/zipkin-vs-pinpoint.html">比较</a></li>
</ul>
<div class="nav-next">
<p><strong>Next:</strong> <a href="../high-performance/index.html">高性能编程</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../monitoring-tracing/pinpoint.html#pinpoint" class="header">Pinpoint</a>
  <ul>
    <li><a href="../monitoring-tracing/pinpoint.html#分布式事务追踪" class="header">分布式事务追踪</a></li>
    <li><a href="../monitoring-tracing/pinpoint.html#字节码增强" class="header">字节码增强</a></li>
    <li><a href="../monitoring-tracing/pinpoint.html#与-zipkin-对比" class="header">与 Zipkin 对比</a></li>
    <li><a href="../monitoring-tracing/pinpoint.html#reference" class="header">Reference</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2018</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '1.0', '')});</script>


</html>
