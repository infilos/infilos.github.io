<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Integration · Infilos</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Infilos'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../js/page.js"></script>
<script type="text/javascript" src="../../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../../js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../../css/page.css"/>

<!--
<link rel="shortcut icon" href="../../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../../index.html" >
<span class="home-icon">⌂</span>Infilos
</a>
<div class="version-number">
1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../../java-lang/index.html" class="page">Java Lang</a>
  <ul>
    <li><a href="../../java-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../java-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../java-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../java-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../java-concur/index.html" class="page">Java Concurrency</a>
  <ul>
    <li><a href="../../java-concur/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-lang/index.html" class="page">Scala Lang</a>
  <ul>
    <li><a href="../../scala-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../scala-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../scala-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../scala-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-concur/index.html" class="page">Scala Concurrency</a></li>
  <li><a href="../../monitoring-tracing/index.html" class="page">Monitoring &amp; Tracing</a>
  <ul>
    <li><a href="../../monitoring-tracing/google-dapper-essentials.html" class="page">Google Dapper</a></li>
    <li><a href="../../monitoring-tracing/opentracing-spec.html" class="page">OpenTracing</a></li>
    <li><a href="../../monitoring-tracing/zipkin/index.html" class="page">Zipkin</a></li>
    <li><a href="../../monitoring-tracing/pinpoint.html" class="page">Pinpoint</a></li>
  </ul></li>
  <li><a href="../../high-performance/index.html" class="page">High Performance</a>
  <ul>
    <li><a href="../../high-performance/ipph/index.html" class="page">深入并行编程</a></li>
    <li><a href="../../high-performance/seven-model/index.html" class="page">并发编程模型</a></li>
    <li><a href="../../high-performance/java-thread-model/index.html" class="page">Java 并发模型</a></li>
    <li><a href="../../high-performance/jc-practice/index.html" class="page">Java 并发实践</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../../index.html">Infilos</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../../index.html" >
<span class="home-icon">⌂</span>Infilos
</a>
<div class="version-number">
1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../../java-lang/index.html" class="page">Java Lang</a>
  <ul>
    <li><a href="../../java-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../java-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../java-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../java-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../java-concur/index.html" class="page">Java Concurrency</a>
  <ul>
    <li><a href="../../java-concur/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-lang/index.html" class="page">Scala Lang</a>
  <ul>
    <li><a href="../../scala-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../scala-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../scala-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../scala-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-concur/index.html" class="page">Scala Concurrency</a></li>
  <li><a href="../../monitoring-tracing/index.html" class="page">Monitoring &amp; Tracing</a>
  <ul>
    <li><a href="../../monitoring-tracing/google-dapper-essentials.html" class="page">Google Dapper</a></li>
    <li><a href="../../monitoring-tracing/opentracing-spec.html" class="page">OpenTracing</a></li>
    <li><a href="../../monitoring-tracing/zipkin/index.html" class="page">Zipkin</a></li>
    <li><a href="../../monitoring-tracing/pinpoint.html" class="page">Pinpoint</a></li>
  </ul></li>
  <li><a href="../../high-performance/index.html" class="page">High Performance</a>
  <ul>
    <li><a href="../../high-performance/ipph/index.html" class="page">深入并行编程</a></li>
    <li><a href="../../high-performance/seven-model/index.html" class="page">并发编程模型</a></li>
    <li><a href="../../high-performance/java-thread-model/index.html" class="page">Java 并发模型</a></li>
    <li><a href="../../high-performance/jc-practice/index.html" class="page">Java 并发实践</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../../index.html">Infilos</a></li>
  <li><a href="../../monitoring-tracing/index.html">Monitoring &amp; Tracing</a></li>
  <li><a href="../../monitoring-tracing/zipkin/index.html">Zipkin</a></li>
  <li>Integration</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#integration" name="integration" class="anchor"><span class="anchor-link"></span></a>Integration</h1>
<h2><a href="#概览" name="概览" class="anchor"><span class="anchor-link"></span></a>概览</h2>
<p>在集成一个类库之前，你需要理解并创建一下元素：</p>
<ul>
  <li>核心数据结构：被收集并发送给 Zipkin 的信息。</li>
  <li>追踪标识符：需要提供哪些标签，以便能够让 Zipkin 基于一定的逻辑顺序重新进行组织。
    <ul>
      <li>生成标识符 - 如何生成标识符、又有哪些标识符需要被继承。</li>
      <li>追踪信息的通信 - 随着追踪及其 ID 发送给 Zipkin 的额外信息。</li>
    </ul>
  </li>
  <li>时间戳与持续时间 - 如何记录一个操作的计时信息。</li>
</ul>
<h2><a href="#核心数据结构" name="核心数据结构" class="anchor"><span class="anchor-link"></span></a>核心数据结构</h2>
<p>核心数据结构在 <a href="https://github.com/openzipkin/zipkin-api/blob/master/thrift/zipkinCore.thrift">Thrift 的注释中</a>提供了详细的说明。这里仅提供一个高层次的抽象。</p>
<h3><a href="#标注-annotation-" name="标注-annotation-" class="anchor"><span class="anchor-link"></span></a>标注(Annotation)</h3>
<p>一个 Annotation 用于按时记录一个事件。这里有一些核心的标注用于定义一个 RPC 请求的开始与结束：</p>
<ul>
  <li>cs - Client Send，客户端发起请求，用于设置一个 Span 的开始。</li>
  <li>sr - Server Receive，服务端接收到请求并开始处理。与 cs 的区别在于对网络延迟和时钟抖动的整合。</li>
  <li>ss - Server Send，服务端完成对请求的处理并向客户端返回响应。与 sr 的区别在于服务端处理请求所耗费的时间总量。</li>
  <li>cr - Client Receive，客户端收到服务端的响应，用于设置一个 Span 的终止。当记录该标注时也意味着该 RPC 的完成。</li>
</ul>
<p>当使用消息代理来代替 RPC 时，则使用下面的标注来阐明流程的方向：</p>
<ul>
  <li>ms - Message Send，生产者发送消息到消息代理。</li>
  <li>mr - Message Receive，消费者从消息代理接收到消息。</li>
</ul>
<p>不同于 RPC，基于消息的 Span 从不会共享 Spanid。比如，同一消息的不同消费者会基于生产者 Span 生成不同的子 Span。</p>
<p>可以在请求的生命周期内记录其他标注来提供更多有意义的信息。比如在服务端开始和结束一个昂贵的计算时添加一些额外的标注，能够为处理前、处理后以及计算过程所花费的具体时间提供更加深入的了解。</p>
<h3><a href="#二元标注-binaryannotation-" name="二元标注-binaryannotation-" class="anchor"><span class="anchor-link"></span></a>二元标注(BinaryAnnotation)</h3>
<p>二元标注并不提供时间属性，主要用来存放业务相关的数据。它们用于为 RPC 提供额外的信息。比如在调用 HTTP 服务时，提供所调用的 URI 能够为后续对所有请求的分析提供帮助。二元标注同样可以用于在 Zipkin API 和 UI 中提供准确的匹配搜索。</p>
<h4><a href="#endpoint" name="endpoint" class="anchor"><span class="anchor-link"></span></a>Endpoint</h4>
<p>端点标注与二元标注均拥有与之关联的端点。但有两个例外，此端点与被追踪的进程相关联。比如，Zipkin UI 中的服务名会与 Annotation.endpoint.serviceName 或 BinaryAnnotation.endpoint.serviceName 相关联。为了便于使用，应该绑定 Endpoint.serviceName 的基数。比如它不能包含一个随机数变量。</p>
<h4><a href="#span" name="span" class="anchor"><span class="anchor-link"></span></a>Span</h4>
<p>一组对应到实际 RPC 的标注和二元标注。Span 包含一些标识信息，如：Traceid、Spanid、Parentid 以及 RPC 名称。</p>
<p>Span 通常会很小。比如其序列化形式通常会以 KiB 单位来衡量甚至更小。如果 Span 增长超过 KiB 级别则会引起其他问题，比如超出 Kafka 的消息大小限制(1 MiB)。尽管你能增加消息的大小限制，过大的 Span 仍然会增加消耗同时降低追踪系统的可用性。因此，应该有意识的仅保存那些有助于解释系统行为的数据。</p>
<h4><a href="#trace" name="trace" class="anchor"><span class="anchor-link"></span></a>Trace</h4>
<p>共享单个根 Span 的一组 Span。Trace 的构建基于对所有拥有相同 Traceid 的 Span 的汇集。然后再基于 Spanid 和 Parentid 将所有 Span 排列为一棵树，以展示一次请求在系统中的处理路径。</p>
<h2><a href="#追踪标识符" name="追踪标识符" class="anchor"><span class="anchor-link"></span></a>追踪标识符</h2>
<p>为了能够将一组 Span 重新组织为一颗完整的树，需要三种信息。Trace 标识符可以是 128 位，而树中的 Span 标示符则总是 64 位。</p>
<p><strong>Traceid</strong></p>
<p>整个 Trace 的 64 或 128 位 ID。Trace 中的所有 Span 均共享该 ID。</p>
<p><strong>Spanid</strong></p>
<p>一个实际 Span 的 ID。为根 Span 时则等同与 Traceid。</p>
<p><strong>Parentid</strong></p>
<p>这是一个可选 ID，仅用于表示一个子 Span 的父 Span。当一个 Span 没有 Parentid 时则为根 Span。</p>
<h3><a href="#生成标识符" name="生成标识符" class="anchor"><span class="anchor-link"></span></a>生成标识符</h3>
<p>让我们看一起如何识别 Span。</p>
<p>当一个传入的请求没有任何附加的追踪信息时，我们会生成一个随机的 Traceid 和 Spanid。Spanid 可以复用 Traceid 的低 64 位，或者也可以完全不同。</p>
<p>如果该请求已经携带追踪信息，服务将会使用这些信息，于是服务端接收、服务端发送事件则会像客户端发出、客户端接收事件一样作为同一个 Span 的一部分。</p>
<p>如果一个服务调用一个下游服务，则会在下游服务中创建一个处于上游服务中的前任 Span 的子 Span。该子 Span 会通过相同的 Traceid 被标识，带有一个新的 Spanid，而 Parentid 则被设置为前任 Span 的 Spanid。该新的 Spanid 需要是一个 64 位的随机值。</p>
<p>注意：如果该服务向多个下游发起调用，则需要重复进行上述过程。每个后续的 Span 都拥有相同的 Traceid 和 Parentid，但是均持有不同的新的 Spanid。</p>
<h3><a href="#追踪信息通信" name="追踪信息通信" class="anchor"><span class="anchor-link"></span></a>追踪信息通信</h3>
<p>追踪信息需要在上下游服务之间传递，以便能够重新组织一个完整的树。共需要 5 个部分的信息：</p>
<ul>
  <li>Traceid</li>
  <li>Spanid</li>
  <li>Parentid</li>
  <li>Sampled，告诉下游是否需要记录该请求的追踪信息。</li>
  <li>Flags，提供能够创建和通信特性标签的能力。这也是我们能够告诉下游该请求为 ”debug“ 级别的方式。</li>
</ul>
<p>查看<a href="https://github.com/openzipkin/b3-propagation">这里</a>来详细了解信息传播的格式规范。</p>
<p>Finagle 为通过 HTTP 或 Thrift 传播这些信息提供了机制。其他协议则需要对这些信息进行扩展以使得追踪变得有效。</p>
<p><strong>Instrumentation sampling decisions are made at the edge of the system</strong></p>
<p>下游服务必须遵循上游服务对采用做出的决定。如果传入的请求并未携带 ”Sampled“ 信息，则类库需要做出决定是否需要对该请求进行采样，并在后续对下游的请求中保持该决定。这简化了是否进行采用的判断逻辑。同时确保了一个请求要么被完整追踪、要么不做任何追踪，使得采样策略更易于理解和配置。</p>
<p>注意，debug 标记会使得一个追踪被强制采样，该机制凌驾于所有采样规则之上。该 debug 标记同样作用于存储层的采样，这部分配置在 Zipkin 的服务端。</p>
<h4><a href="#http-tracing" name="http-tracing" class="anchor"><span class="anchor-link"></span></a>HTTP Tracing</h4>
<p>HTTP 首部用于传递较长的追踪信息。</p>
<p>首部中的 B3 部分是以 Zipkin 的原始名称命名的：BigBrotherBird。</p>
<p>所有 ID 类的值均以 16 进制字符串形式表示:</p>
<p>X-B3-TraceId: 128 or 64 lower-hex encoded bits (required) X-B3-SpanId: 64 lower-hex encoded bits (required) X-B3-ParentSpanId: 64 lower-hex encoded bits (absent on root span) X-B3-Sampled: Boolean (either “1” or “0”, can be absent) X-B3-Flags: “1” means debug (can be absent)</p>
<p>要了解 B3 的更多信息，可以参考其声明规范。</p>
<h4><a href="#thrift-tracing" name="thrift-tracing" class="anchor"><span class="anchor-link"></span></a>Thrift Tracing</h4>
<p>当一个新的请求被建立时，Finagle 客户端和服务端通过 thrift 消息的首部来沟通是否能够处理额外的信息。一旦确认则所有的追踪数据将会被打包到所有 thrift 消息的首部中。</p>
<h2><a href="#时间戳与持续时长" name="时间戳与持续时长" class="anchor"><span class="anchor-link"></span></a>时间戳与持续时长</h2>
<p>Span 会在计时信息或元信息构造完成并发送给 Zipkin 时被记录。该过程的一个重要部分是正确的记录时间戳和持续时间。</p>
<p><strong>Timestamps are microseconds</strong></p>
<p>Zipkin 中的所有时间戳均为微秒单位(而非毫秒)。该值需要被尽可能精确的度量。比如，直接使用 <code>clock_gettime</code> 或者将毫秒乘以 1000。时间戳字段被保存为 64 位有符号整数，尽管负数是无效的。</p>
<p>微秒精度主要是为了支持 ”本地 Span“，即进程被操作。比如，基于更高的精度，你可以准确描述事件的先后顺序。</p>
<p>所有时间戳都存在一定的误差，包括时钟抖动以及主机与时间服务之间向后重置时钟的时机。因此，Span 应该在一旦可能的时候立即记录其持续时间。</p>
<p><strong>Span duration is also microseconds</strong></p>
<p>如果可以获得纳秒精度的计时信息，Zipkin 则会采用微秒粒度。以下是这么做的原因：</p>
<p>首先，使用相同的时间戳单元是运算变得更加简单。比如你正在排查一个 Span，则更容易识别基于相同时间单元的条目。</p>
<p>其次，记录一个 Span 的负载可能会不断变化，可以是微秒或者更多：采用比负载更高的分辨率则会分散注意力。</p>
<p>在 Zipkin 的未来版本中可能会重新设定该主题，但就目前来说，一切都以微秒为单位。</p>
<p><strong>When to set Span.timestamp and duration</strong></p>
<p>Span 的时间戳和持续时间仅应该有创建该 Span 的主机来设置。</p>
<p>下面是设置的逻辑：</p>
<pre><code>unless (logging &quot;sr&quot; in an existing span) {
 set Span.timestamp and duration
}
</code></pre>
<p>Zipkin 会将拥有相同 Traceid 和 Spanid 的追踪进行聚合。常见的例子是同时在客户端(cs, cr)和服务端(sr, ss)合并一个 Span。比如，客户端开始一个 Span，记下 ”cs“ 并通过 B3 首部将其传播，然后服务端通过记录一个 ”sr“ 来继续该 Span。</p>
<p>在这个例子中，Span 由客户端开启，因此应该由客户端来设置其时间戳和持续时长，而且这些值应该能够正确匹配 ”cs“ 和 ”cr“ 之间的不同。该 Span 并非由服务端开启，因此不应设置该 Span 的时间戳和持续时长。</p>
<p>另一个常见的例子是服务端基于一个未被追踪的客户端发起的请求开启一个根 Span，类似一个 Web 服务器。因为 B3 首部中并没有包含任何信息或任何其他类似的信息，因此服务端知道它应该开启一个追踪实例。一旦追踪被创建，则它应该负责记录该根 Span 的时间戳和持续时长。</p>
<p>注意：一旦一个 Span 完成，你需要设置 Span 的时间戳，但并不能设置其持续时长，因为并没有足够的信息来准确的设置它的值。</p>
<p><strong>What happens when Span.timestamp and duration are not set?</strong></p>
<p>Span 的时间戳和持续时长是在 Zipkin 项目开始后第三年的时候(2015)添加的字段。并非所有的类库都会记录这些信息。如果这些字段没有被设置，Zipkin 会在查询它们的时候在组织数据时添加(查询时的)当前值；这种做法并不理想。</p>
<p><a href="https://zipkin.io/zipkin-api/#/paths/%252Ftraces/get/parameters/minDuration">基于持续时长的查询</a>将会失败，因为没有数据可查(并未设置这些值)。同时，进程内的 Span 并不要求必须拥有标注，因此如果不设置时间戳则同样无法被查询。</p>
<p>如果持续时长没有被追踪装置设置，Zipkin 则会尝试在查询时追加时间，这时则不得不使用充满缺陷的时间戳运算方法。比如，如果 Span 内部的 NTP 被更新了，则 Zipkin 运算出的持续时间则是不准确的。</p>
<p>最终，大家会寄期望于单主机 Span。向这种方式迁移的路径是将双主机的 RPC Span 拆分为两个 Span。当追踪装置仅为其拥有的 Span 记录时间戳时，拆分收集器具有启发式功能，它能在由服务端创建的根 Span 和由客户端创建的根 Span 之间进行区分。</p>
<p>选择不记录 Span 的时间戳和持续时长则会导致正确数据的缺失以及更多的功能。因为要精确的记录这些值还是很简单的，因此所有的 Zipkin 装置均应提供相应的实现。</p>
<h2><a href="#one-way-rpc-tracing" name="one-way-rpc-tracing" class="anchor"><span class="anchor-link"></span></a>One-way RPC Tracing</h2>
<p>One-way(单行) 类似于常规的 RPC 追踪，然而它并不期望响应。</p>
<p>在常规的 RPC 追踪中有 4 种标注：“cs” “sr” 用于请求，而 “ss” “cr” 用于响应。在单行追踪中，仅使用前两者，因为没有响应会返回给调用者。</p>
<p>因此客户端但会将 “cs” 添加到 Span 并报告给 Zipkin。然后，服务端会为 Span 添加 “sr” 并报告给 Zipkin。任何一端都不会添加 Span 的时间戳和持续时长，因为它们都不知道 Span 的开始或结束时间。</p>
<p>下面是单行 RPC 追踪的流程图：</p>
<pre><code>   Client Tracer                                      Server Tracer
+------------------+                               +------------------+
| +--------------+ |     +-----------------+       | +--------------+ |
| | TraceContext |======&gt;| Request Headers |========&gt;| TraceContext | |
| +--------------+ |     +-----------------+       | +--------------+ |
+--------||--------+                               +--------||--------+
   start ||                                                 ||
         \/                                          finish ||
span(context).annotate(&quot;cs&quot;)                                \/
                                             span(context).annotate(&quot;sr&quot;)
</code></pre>
<p>下面是该过程在 Brave Tracer 中的应用实例：</p>
<p>客户端:</p>
<pre class="prettyprint"><code class="language-java">// Add trace identifiers to the outbound span
tracing.propagation().injector(Request::addHeader)
       .inject(span.context(), request);

client.send(request);

// start the client side and flush instead of processing a response
span.kind(Span.Kind.CLIENT)
    .start().flush();

// The above will report to zipkin trace identifiers, a &quot;cs&quot; annotation with the
// endpoint of the client
</code></pre>
<p>服务端:</p>
<pre class="prettyprint"><code class="language-java">// Parse the span from request headers
TraceContextOrSamplingFlags result =
    tracing.propagation().extractor(Request::getHeader).extract(request);

// Reuse the same span ids by joining that context
span = tracer.joinSpan(result.context())

// start the server side and flush instead of processing a response
span.kind(Span.Kind.SERVER)
    .start().flush();

// The above will report to zipkin trace identifiers, a &quot;sr&quot; annotation with the
// endpoint of the server
</code></pre>
<p>上面的流程中假设一个追踪器能够 “flush” Span，它会简单地将 Span 发送给 Zipkin 而不会尝试在本地计算持续时长。</p>
<h2><a href="#message-tracing" name="message-tracing" class="anchor"><span class="anchor-link"></span></a>Message Tracing</h2>
<p>消息追踪不同与 RPC 追踪，因为生产者和消费者之间并不共用 Spanid。</p>
<p>在常规的 RPC 追踪中，客户端和服务端标注会在相同的 Span 中持续。但在消息追踪中行不通，因为同一个消息可能存在多个消费者。</p>
<p>类似于单行 RPC 追踪，消息追踪中不存在响应路径：仅会使用 “ms” 和 “mr” 两个标注。但又不同于单行 RPC 追踪，可以为生产者和每个消费者之间各个独立的 Span 添加时间戳和持续时长。</p>
<p>因此，生产者为 Span 添加 “ms” 标注并发送给 Zipkin。然后，每个消费者会创建一个子 Span 并为其添加 “mr” 标注。</p>
<p>下面是消息追踪的流程图：</p>
<pre><code>   Producer Tracer                                    Consumer Tracer
+------------------+                               +------------------+
| +--------------+ |     +-----------------+       | +--------------+ |
| | TraceContext |======&gt;| Message Headers |========&gt;| TraceContext | |
| +--------------+ |     +-----------------+       | +--------------+ |
+--------||--------+                               +--------||--------+
   start ||                                                 ||
         \/                                          finish ||
span(context).annotate(&quot;ms&quot;)                                \/
             .address(&quot;ma&quot;, broker)          span(context).annotate(&quot;mr&quot;)
                                                          .address(&quot;ma&quot;, broker)
</code></pre>
<p>下面是该过程在 Brave Tracer 中的应用实例:</p>
<p>生产端:</p>
<pre class="prettyprint"><code class="language-java">// Add trace identifiers to the outbound span
tracing.propagation().injector(Message::addHeader)
       .inject(span.context(), message);

producer.send(message);

// start and finish the producer side
span.kind(Span.Kind.PRODUCER)
    .remoteEndpoint(broker.endpoint())
    .start().finish();

// The above will report to zipkin trace identifiers, a &quot;ms&quot; annotation with the
// endpoint of the producer, and a &quot;ma&quot; (Message Address) with the endpoint of
// the broker
</code></pre>
<p>消费端:</p>
<pre class="prettyprint"><code class="language-java">// Parse the span from message headers
TraceContextOrSamplingFlags result =
    tracing.propagation().extractor(Message::getHeader).extract(message);

// Reuse the same span ids by joining that context
span = tracer.newChild(result.context())

// start and finish the consumer side indicating the message arrived.
span.kind(Span.Kind.CONSUMER)
    .remoteEndpoint(broker.endpoint())
    .start().finish();

// The above will report to zipkin trace identifiers, a &quot;mr&quot; annotation with the
// endpoint of the consumer, and a &quot;ma&quot; (Message Address) with the endpoint of
// the broker.
</code></pre>
<p>很多消费者会分散处理过程，在同一时间接收大量的消息。将每个消费者的追踪上下文注入到对应的消息首部将会有所帮助。这样一来处理器能够在整个追踪树的合适位置为其创建子 Span。</p>
<p>下面是基于 Kafka 的拉取 API 对该过程的应用实例：</p>
<pre class="prettyprint"><code class="language-java">public ConsumerRecords&lt;K, V&gt; poll(long timeout) {
  ConsumerRecords&lt;K, V&gt; records = delegate.poll(timeout);
  for (ConsumerRecord&lt;K, V&gt; record : records) {
    handleConsumed(record);
  }
  return records;
}

void handleConsumed(ConsumerRecord record) {
  // notifies zipkin the record arrived
  Span span = startAndFinishConsumerSpan(record);
  // allows a processor to see the parent ID (the consumer trace context)
  injector.inject(span.context(), record.headers());
}
</code></pre>
<div class="nav-next">
<p><strong>Next:</strong> <a href="../../monitoring-tracing/zipkin/tracing.html">Tracing</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../../monitoring-tracing/zipkin/integration.html#integration" class="header">Integration</a>
  <ul>
    <li><a href="../../monitoring-tracing/zipkin/integration.html#概览" class="header">概览</a></li>
    <li><a href="../../monitoring-tracing/zipkin/integration.html#核心数据结构" class="header">核心数据结构</a></li>
    <li><a href="../../monitoring-tracing/zipkin/integration.html#追踪标识符" class="header">追踪标识符</a></li>
    <li><a href="../../monitoring-tracing/zipkin/integration.html#时间戳与持续时长" class="header">时间戳与持续时长</a></li>
    <li><a href="../../monitoring-tracing/zipkin/integration.html#one-way-rpc-tracing" class="header">One-way RPC Tracing</a></li>
    <li><a href="../../monitoring-tracing/zipkin/integration.html#message-tracing" class="header">Message Tracing</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2018</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '1.0', '')});</script>


</html>
