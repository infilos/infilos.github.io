<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Propagation · Infilos</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Infilos'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../js/page.js"></script>
<script type="text/javascript" src="../../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../../js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../../css/page.css"/>

<!--
<link rel="shortcut icon" href="../../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../../index.html" >
<span class="home-icon">⌂</span>Infilos
</a>
<div class="version-number">
1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../../vm/index.html" class="page">虚拟机</a>
  <ul>
    <li><a href="../../vm/java-vm/index.html" class="page">Java VM</a></li>
  </ul></li>
  <li><a href="../../java-lang/index.html" class="page">Java Lang</a>
  <ul>
    <li><a href="../../java-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../java-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../java-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../java-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../java-concur/index.html" class="page">Java Concurrency</a>
  <ul>
    <li><a href="../../java-concur/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-lang/index.html" class="page">Scala Lang</a>
  <ul>
    <li><a href="../../scala-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../scala-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../scala-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../scala-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-concur/index.html" class="page">Scala Concurrency</a></li>
  <li><a href="../../monitoring-tracing/index.html" class="page">监控与追踪</a>
  <ul>
    <li><a href="../../monitoring-tracing/google-dapper-essentials.html" class="page">Google Dapper</a></li>
    <li><a href="../../monitoring-tracing/opentracing-spec.html" class="page">OpenTracing</a></li>
    <li><a href="../../monitoring-tracing/zipkin/index.html" class="page">Zipkin</a></li>
    <li><a href="../../monitoring-tracing/pinpoint.html" class="page">Pinpoint</a></li>
  </ul></li>
  <li><a href="../../high-performance/index.html" class="page">高性能编程</a>
  <ul>
    <li><a href="../../high-performance/ipph/index.html" class="page">深入并行编程</a></li>
    <li><a href="../../high-performance/seven-model/index.html" class="page">并发编程模型</a></li>
    <li><a href="../../high-performance/java-thread-model/index.html" class="page">Java 并发模型</a></li>
    <li><a href="../../high-performance/jc-practice/index.html" class="page">Java 并发实践</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../../index.html">Infilos</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../../index.html" >
<span class="home-icon">⌂</span>Infilos
</a>
<div class="version-number">
1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../../vm/index.html" class="page">虚拟机</a>
  <ul>
    <li><a href="../../vm/java-vm/index.html" class="page">Java VM</a></li>
  </ul></li>
  <li><a href="../../java-lang/index.html" class="page">Java Lang</a>
  <ul>
    <li><a href="../../java-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../java-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../java-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../java-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../java-concur/index.html" class="page">Java Concurrency</a>
  <ul>
    <li><a href="../../java-concur/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-lang/index.html" class="page">Scala Lang</a>
  <ul>
    <li><a href="../../scala-lang/basics/index.html" class="page">Basics</a></li>
    <li><a href="../../scala-lang/effects/index.html" class="page">Effectives</a></li>
    <li><a href="../../scala-lang/profess/index.html" class="page">Professionals</a></li>
    <li><a href="../../scala-lang/puzzles/index.html" class="page">Puzzles</a></li>
  </ul></li>
  <li><a href="../../scala-concur/index.html" class="page">Scala Concurrency</a></li>
  <li><a href="../../monitoring-tracing/index.html" class="page">监控与追踪</a>
  <ul>
    <li><a href="../../monitoring-tracing/google-dapper-essentials.html" class="page">Google Dapper</a></li>
    <li><a href="../../monitoring-tracing/opentracing-spec.html" class="page">OpenTracing</a></li>
    <li><a href="../../monitoring-tracing/zipkin/index.html" class="page">Zipkin</a></li>
    <li><a href="../../monitoring-tracing/pinpoint.html" class="page">Pinpoint</a></li>
  </ul></li>
  <li><a href="../../high-performance/index.html" class="page">高性能编程</a>
  <ul>
    <li><a href="../../high-performance/ipph/index.html" class="page">深入并行编程</a></li>
    <li><a href="../../high-performance/seven-model/index.html" class="page">并发编程模型</a></li>
    <li><a href="../../high-performance/java-thread-model/index.html" class="page">Java 并发模型</a></li>
    <li><a href="../../high-performance/jc-practice/index.html" class="page">Java 并发实践</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../../index.html">Infilos</a></li>
  <li><a href="../../monitoring-tracing/index.html">监控与追踪</a></li>
  <li><a href="../../monitoring-tracing/zipkin/index.html">Zipkin</a></li>
  <li>Propagation</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#propagation" name="propagation" class="anchor"><span class="anchor-link"></span></a>Propagation</h1>
<p>追踪信息的传播包括**进程内传播**和**跨进程传播**，而信息的主体主要是 TraceContext，Span 只是用来给用户构建追踪信息的工具。</p>
<h2><a href="#tracecontext" name="tracecontext" class="anchor"><span class="anchor-link"></span></a>TraceContext</h2>
<pre class="prettyprint"><code class="language-java">TraceContext extends SamplingFlags {
	/** When non-zero, the trace containing this span uses 128-bit trace identifiers. */
  	public long traceIdHigh() {
    	return traceIdHigh;
  	}
  
  	/** Unique 8-byte identifier for a trace, set on all spans within it. */
  	public long traceId() {
    	return traceId;
  	}
  
  /**
   * The parent&#39;s {@link #spanId} or null if this the root span in a trace.
   *
   * @see #parentIdAsLong()
   */
  	@Nullable public final Long parentId() {
    	return parentId != 0 ? parentId : null;
  	}
  
  	// extends from SamplingFlags
  	final Boolean sampled;
	final boolean debug;
}
</code></pre>
<p><code>TraceContext</code> 中包含了必要的追踪标识符和采样标记，用于进程内、跨进程方式的追踪信息传播。</p>
<ul>
  <li>traceIdHigh，如果不为 0，则所有关联该 TraceContext 的 Span 均采用 128 位追踪标识符。</li>
  <li>traceId，关联到所有 Span 的 8 字节即 64 位追踪标识符。</li>
  <li>parentId，如果为 null 则表示根 Span，否则为子 Span。</li>
  <li>sampled，是否采样。</li>
  <li>debug，是否为 debug 模式，如果为 true 则忽略采样标记仍然发送该追踪。</li>
</ul>
<p><code>TraceContext</code> 内部包含两个接口、</p>
<h2><a href="#traceidcontext" name="traceidcontext" class="anchor"><span class="anchor-link"></span></a>TraceIdContext</h2>
<p>与 <code>TraceContext</code> 类似，但不包括 Spanid，用在一些不需要控制 Spanid 的场景。</p>
<h2><a href="#tracecontextorsamplingflags" name="tracecontextorsamplingflags" class="anchor"><span class="anchor-link"></span></a>TraceContextOrSamplingFlags</h2>
<p>可能包含 TraceContext、TraceidContext、SamplingFlag 三者其中的一种，用于在跨进程传播时从载体中提取可能存在的追踪信息。</p>
<h2><a href="#currenttracecontext" name="currenttracecontext" class="anchor"><span class="anchor-link"></span></a>CurrentTraceContext</h2>
<p>用于进程内传播。</p>
<p><code>CurrentTraceContext</code> 是一个 SPI，内部提供了一个基于 <code>ThreadLocal</code> 的默认实现 <code>Default</code>。该类用于将当前 Span 放置到一个 Scope，以便能够避免通过参数来传递 Span。</p>
<p>内部接口 <code>Scope</code> 实现了 <code>Closeable</code> 以便自动结束对当前 Span 和 Scope 的捆绑。</p>
<pre class="prettyprint"><code class="language-java">Default extends CurrentTraceContext {
	// omitted...
    public static CurrentTraceContext create() {
      return new Default(DEFAULT);
    }
    
    public static CurrentTraceContext inheritable() {
      return new Default(INHERITABLE);
    }
    
    @Override public TraceContext get() {
      return local.get();
    }
    
    @Override public Scope newScope(@Nullable TraceContext currentSpan) {
      final TraceContext previous = local.get();
      local.set(currentSpan);
      class DefaultCurrentTraceContextScope implements Scope {
        @Override public void close() {
          local.set(previous);
        }
      }
      return new DefaultCurrentTraceContextScope();
    }
}
</code></pre>
<p>默认实现中提供了 <code>ThreadLocal</code> 和 <code>InheritableThreadLocal</code> 两种方式，以应对业务代码中不同的线程用法，实现 <code>TraceContext</code> 当当前线程的绑定。</p>
<p><code>newScope</code> 方法将基于参数中传入的 Span 创建一个 <code>Sope</code>：首先将当前线程中的 TraceContext 取出，然后设置为参数传入的 TraceContext；然后实现一个匿名的 Scope 实现，该实现将在 close 方法调用时自动将前面取出的 TraceContext 重新绑定到当前线程。</p>
<p>基于该实现，<code>Tracer</code> 中提供了一个 <code>withSpanInScope</code> 方法来使用该实现，以支持下面这种用法：</p>
<pre class="prettyprint"><code class="language-java">TraceContext traceContext1;
TraceContext traceContext2;
try (Scope scope = newScope(traceContext1)) {
  // 1.此处CurrentTraceContext.get()能获得traceContext1
  try (Scope scope = newScope(traceContext2)) {
  	// 2.此处CurrentTraceContext.get()能获得traceContext2
  }
  // 3.此处CurrentTraceContext.get()能获得traceContext1
}
</code></pre>
<p><code>CurrentTraceContext</code> 还为线程的执行提供了封装方法：</p>
<pre class="prettyprint"><code class="language-java">public &lt;C&gt; Callable&lt;C&gt; wrap(Callable&lt;C&gt; task) {
    final TraceContext invocationContext = get();
    class CurrentTraceContextCallable implements Callable&lt;C&gt; {
      @Override public C call() throws Exception {
        try (Scope scope = maybeScope(invocationContext)) {
          return task.call();
        }
      }
    }
    return new CurrentTraceContextCallable();
  }
</code></pre>
<p>该包装方法利用 Scope 机制来实现跨线程的 TraceContext 传递。同时还提供了接收 <code>Runnable</code> 的封装方法；对 <code>Executor</code>、<code>ExecutorService</code> 的封装。</p>
<h2><a href="#threadlocalspan" name="threadlocalspan" class="anchor"><span class="anchor-link"></span></a>ThreadLocalSpan</h2>
<p>该类用于在一个方法内放置 Span，以在其他方法中获取 Span，避免显式的参数传递。</p>
<pre class="prettyprint"><code class="language-java">class MyFilter extends Filter {
	final ThreadLocalSpan threadLocalSpan;

	public void onStart(Request request) {
		// Allocates a span and places it in scope so that 
        // code between here and onFinish can see it
		Span span = threadLocalSpan.next();
		if (span == null || span.isNoop()) return; // skip below logic on noop

		// Assume you have code to start the span and add relevant tags...
	}

	public void onFinish(Response response, Attributes attributes) {
		// as long as we are on the same thread, we can read the span started above
		Span span = threadLocalSpan.remove();
		if (span == null || span.isNoop()) return; // skip below logic on noop
		
        // Assume you have code to complete the span
	}
}
</code></pre>
<h2><a href="#threadcontextcurrenttracecontext" name="threadcontextcurrenttracecontext" class="anchor"><span class="anchor-link"></span></a>ThreadContextCurrentTraceContext</h2>
<p>ThreadContextCurrentTraceContext 是为 log4j2 提供的封装，是 brave-context-log4j2 包中的一个类，在 ThreadContext 中包含 Traceid 和 Spanid 两个属性。然后可以在 log4j2 的配置文件中设置日志格式，使用占位符 %X{traceId} 和 %X{spanId} 来把 Traceid 和 Spanid 关联到日志中。</p>
<pre class="prettyprint"><code class="language-java">public final class ThreadContextCurrentTraceContext extends CurrentTraceContext {
  public static ThreadContextCurrentTraceContext create() {
    return create(CurrentTraceContext.Default.inheritable());
  }

  public static ThreadContextCurrentTraceContext create(CurrentTraceContext delegate) {
    return new ThreadContextCurrentTraceContext(delegate);
  }

  final CurrentTraceContext delegate;

  ThreadContextCurrentTraceContext(CurrentTraceContext delegate) {
    if (delegate == null) throw new NullPointerException(&quot;delegate == null&quot;);
    this.delegate = delegate;
  }

  @Override public TraceContext get() {
    return delegate.get();
  }

  @Override public Scope newScope(@Nullable TraceContext currentSpan) {
    final String previousTraceId = ThreadContext.get(&quot;traceId&quot;);
    final String previousSpanId = ThreadContext.get(&quot;spanId&quot;);

    if (currentSpan != null) {
      ThreadContext.put(&quot;traceId&quot;, currentSpan.traceIdString());
      ThreadContext.put(&quot;spanId&quot;, HexCodec.toLowerHex(currentSpan.spanId()));
    } else {
      ThreadContext.remove(&quot;traceId&quot;);
      ThreadContext.remove(&quot;spanId&quot;);
    }

    Scope scope = delegate.newScope(currentSpan);
    class ThreadContextCurrentTraceContextScope implements Scope {
      @Override public void close() {
        scope.close();
        ThreadContext.put(&quot;traceId&quot;, previousTraceId);
        ThreadContext.put(&quot;spanId&quot;, previousSpanId);
      }
    }
    return new ThreadContextCurrentTraceContextScope();
  }
}
</code></pre>
<p>ThreadContextCurrentTraceContext 继承了 CurrentTraceContext，覆盖了其 newScope 方法，提取了 currentSpan 中的 Traceid 和 Spanid 放到 log4j2 的上下文对象 ThreadContext 中。</p>
<p>在<a href="https://github.com/openzipkin/brave/tree/master/context">源码</a>中能够找到对 slf4j 的支持。</p>
<h2><a href="#跨进程传播" name="跨进程传播" class="anchor"><span class="anchor-link"></span></a>跨进程传播</h2>
<p><code>TraceContext</code> 内部还定义了两个接口：</p>
<pre class="prettyprint"><code class="language-java">public interface Injector&lt;C&gt; {
	void inject(TraceContext traceContext, C carrier);
}  
public interface Extractor&lt;C&gt; {
	TraceContextOrSamplingFlags extract(C carrier);
}
</code></pre>
<ul>
  <li>Injector：用于将 TraceContext 中的各种数据注入到 Carrier 中，Carrier 一般指在跨进程通信时类似 HTTP Header 这些能够携带额外信息的对象。</li>
  <li>Extractor：用于从 Carrier 中提取 TraceContext 相关信息或采样标记信息(TraceContextOrSamplingFlags)。</li>
</ul>
<h2><a href="#propagation" name="propagation" class="anchor"><span class="anchor-link"></span></a>Propagation</h2>
<p><code>Propagation</code> 是传播器的接口定义：</p>
<pre class="prettyprint"><code class="language-java">public interface Propagation&lt;K&gt; {
	List&lt;K&gt; keys();
    &lt;C&gt; TraceContext.Injector&lt;C&gt; injector(Setter&lt;C, K&gt; setter);
    &lt;C&gt; TraceContext.Extractor&lt;C&gt; extractor(Getter&lt;C, K&gt; getter);
    
    interface Setter&lt;C, K&gt; {
    	void put(C carrier, K key, String value);
  	}
    interface Getter&lt;C, K&gt; {
    	@Nullable String get(C carrier, K key);
  	}
}
</code></pre>
<p><code>Propagation</code> 带有一个参数化类型 <code>K</code>，表示传播追踪信息时键的类型，比如 <code>String</code>；上面我们介绍过 <code>Injector&lt;C&gt;</code>、<code>Extractor&lt;C&gt;</code> 携带的参数化类型 <code>C</code> 表示载体的类型，比如 <code>HTTPRequest</code> 对象；而 <code>Propagation</code> 内部又提供了两个函数式接口，<code>Setter&lt;C, K&gt;</code> 和 <code>Getter&lt;C, K&gt;</code>，当以特定类型的载体实现追踪信息的注入与提取时，仅需要提供这两个函数式接口的实例即可，同时值类型为固定的 <code>String</code> 类型。</p>
<p>Brave 提供了一个默认实现 <code>B3Propagation</code>：</p>
<pre class="prettyprint"><code class="language-java">public final class B3Propagation&lt;K&gt; implements Propagation&lt;K&gt; {}
</code></pre>
<p>发现其参数化类型 <code>K</code> 仍然没有具体化。再看其内部提供的用来创建传播器实例的工厂方法：</p>
<pre class="prettyprint"><code class="language-java">public static final Propagation.Factory FACTORY = new Propagation.Factory() {
    @Override public &lt;K&gt; Propagation&lt;K&gt; create(KeyFactory&lt;K&gt; keyFactory) {
      return new B3Propagation&lt;&gt;(keyFactory);
    }
    // omitted...
}
</code></pre>
<p>该工厂方法接收一个 <code>KeyFactory&lt;K&gt; keyFactory</code> 参数，<code>KeyFactory&lt;K&gt;</code> 是一个函数式接口，定义在 <code>Propagation</code> 接口内部，其 <code>create</code> 方法接收一个 <code>String</code> 类型的属性名，然后返回一个类型为 <code>K</code> 的传播器键：</p>
<pre class="prettyprint"><code class="language-java">interface KeyFactory&lt;K&gt; {
	K create(String name);
}
</code></pre>
<p>其内部提供了一个默认实现，用于创建 <code>String</code> 类型的传播器键：</p>
<pre class="prettyprint"><code class="language-java">KeyFactory&lt;String&gt; STRING = new KeyFactory&lt;String&gt;() {
	@Override public String create(String name) {
		return name;
	}
};
</code></pre>
<p><code>KeyFactory&lt;K&gt;</code> 这个函数式接口主要用于推迟键类型的具体化，以便在创建传播器实例时再指定键的类型。比如 <code>Propagation</code> 内提供了基于 B3 的默认传播器实现：</p>
<pre class="prettyprint"><code class="language-java">Propagation&lt;String&gt; B3_STRING = 
	B3Propagation.FACTORY.create(Propagation.KeyFactory.STRING);
</code></pre>
<p>再来看 <code>B3Propagation</code> 的内部实现。其内部首先定义类 <code>keys()</code> 方法的值，即 B3 规范中用于传播追踪信息时使用的键名。然后实现了 <code>Injector</code> 和 <code>Extractor</code>，并提供了通过 <code>Setter</code> 和 <code>Setter</code> 来创建 <code>Injector</code> 和 <code>Extractor</code> 实例的方法：</p>
<pre class="prettyprint"><code class="language-java">B3Injector&lt;C, K&gt; implements TraceContext.Injector&lt;C&gt; {
	public void inject(TraceContext traceContext, C carrier) {
      setter.put(carrier, propagation.traceIdKey,traceContext.traceIdString());
      setter.put(carrier, propagation.spanIdKey,toLowerHex(traceContext.spanId()));
      //...
    }
}
B3Extractor&lt;C, K&gt; implements TraceContext.Extractor&lt;C&gt; {
	public TraceContextOrSamplingFlags extract(C carrier) {
    	String sampled = getter.get(carrier, propagation.sampledKey);
        boolean debug = &quot;1&quot;.equals(getter.get(carrier, propagation.debugKey));
        String traceIdString = getter.get(carrier, propagation.traceIdKey);
        // ...
    }
}

public &lt;C&gt; TraceContext.Injector&lt;C&gt; injector(Setter&lt;C, K&gt; setter) {
    if (setter == null) throw new NullPointerException(&quot;setter == null&quot;);
    return new B3Injector&lt;&gt;(this, setter);
}
public &lt;C&gt; TraceContext.Extractor&lt;C&gt; extractor(Getter&lt;C, K&gt; getter) {
    if (getter == null) throw new NullPointerException(&quot;getter == null&quot;);
    return new B3Extractor&lt;&gt;(this, getter);
}
</code></pre>
<p>假设我们现在直接使用前面提供的默认的 <code>B3_STRING</code> 传播器实现，并基于 HTTPRequest 对象进行跨进程的追踪信息传播，则可以这样做：</p>
<pre class="prettyprint"><code class="language-java">Injector&lt;HTTPRequest&gt; injector = B3_STRING.injector(HTTPRequest::addHeader);
Extractor&lt;HTTPRequest&gt; extractor = B3_STRING.extractor(HTTPRequest::getHeader);

// client side
injector.inject(traceContext, httpRequest);

// server size
TraceContextOrSamplingFlags result = extractor.extract(httpRequest);
</code></pre>
<p>传播器的实现过程有点复杂，但这么做的好处显而易见，可以为不同的传播方式、传播数据类型、传播器的构建过程提供最大的灵活性，以便更加简单的集成各种 RPC 协议。</p>
<ul>
  <li>我们可以定制自己的传播键类型：类似 <code>STRING</code> 中直接返回一个 <code>String</code> 类型的键名，我们可以返回一个结构化的键来包含更多信息。</li>
  <li>我们可以定制自己的传播协议：类似 <code>B3Propagation</code> 中对 <code>keys()</code> 返回值的定义，即自己提供一套传播追踪数据时的键名规范。</li>
  <li>基于以上二者，我们可以定制对追踪信息的注入、提取逻辑，即 <code>Injector</code> 和 <code>Extractor</code> 的实现。</li>
  <li>最后，基于这套规范、注入和提取逻辑，我们可以集成多种不同的 RPC 协议，比如 HTTP、Dubbo、Kafka 等。</li>
</ul>
<h2><a href="#extrafieldpropagation" name="extrafieldpropagation" class="anchor"><span class="anchor-link"></span></a>ExtraFieldPropagation</h2>
<p>提供了一种扩充已有传播器键的机制，比如基于 <code>B3Propagation</code> 传播器，我们可以添加额外的键名，以在传播过程中携带这些键对应的值。</p>
<p><code>ExtraFieldPropagation</code> 提供了一些便利的方法来实现额外键的添加、覆盖、通配。</p>
<pre class="prettyprint"><code class="language-java">static final class ExtraFieldInjector&lt;C, K&gt; implements Injector&lt;C&gt; {
  final Injector&lt;C&gt; delegate;
  final Propagation.Setter&lt;C, K&gt; setter;
  final Map&lt;String, K&gt; nameToKey;

  ExtraFieldInjector(Injector&lt;C&gt; delegate, Setter&lt;C, K&gt; setter, Map&lt;String, K&gt; nameToKey) {
    this.delegate = delegate;
    this.setter = setter;
    this.nameToKey = nameToKey;
  }

  @Override public void inject(TraceContext traceContext, C carrier) {
    for (Object extra : traceContext.extra()) {
      if (extra instanceof Extra) {
        ((Extra) extra).setAll(carrier, setter, nameToKey);
        break;
      }
    }
    delegate.inject(traceContext, carrier);
  }
}
</code></pre>
<p><code>ExtraFieldInjector</code> 的 <code>inject</code> 方法中，将 <code>traceContext</code> 的 <code>extra</code> 数据，<code>set</code> 到 <code>carrier</code> 中，这里的 <code>Extra</code> 对象，其实就是 key-value，有 <code>One</code> 和 <code>Many</code> 两种，<code>Many</code> 时就相当于 <code>Ma</code>p 结构。</p>
<p>在 <code>Extra</code> 中 <code>setAll</code> 方法中，先用 <code>extra</code> 的 <code>name</code> 去 <code>nameToKey</code> 里找，如果没有就不设置，如果找到就调用 <code>setter</code> 的 <code>put</code> 方法将值设置到 <code>carrier</code> 中。</p>
<pre class="prettyprint"><code class="language-java">static final class One extends Extra {
  String name, value;

  @Override void put(String name, String value) {
    this.name = name;
    this.value = value;
  }

  @Override String get(String name) {
    return name.equals(this.name) ? value : null;
  }

  @Override &lt;C, K&gt; void setAll(C carrier, Setter&lt;C, K&gt; setter, Map&lt;String, K&gt; nameToKey) {
    K key = nameToKey.get(name);
    if (key == null) return;
    setter.put(carrier, key, value);
  }

  @Override public String toString() {
    return &quot;ExtraFieldPropagation{&quot; + name + &quot;=&quot; + value + &quot;}&quot;;
  }
}

static final class Many extends Extra {
  final LinkedHashMap&lt;String, String&gt; fields = new LinkedHashMap&lt;&gt;();

  @Override void put(String name, String value) {
    fields.put(name, value);
  }

  @Override String get(String name) {
    return fields.get(name);
  }

  @Override &lt;C, K&gt; void setAll(C carrier, Setter&lt;C, K&gt; setter, Map&lt;String, K&gt; nameToKey) {
    for (Map.Entry&lt;String, String&gt; field : fields.entrySet()) {
      K key = nameToKey.get(field.getKey());
      if (key == null) continue;
      setter.put(carrier, nameToKey.get(field.getKey()), field.getValue());
    }
  }

  @Override public String toString() {
    return &quot;ExtraFieldPropagation&quot; + fields;
  }
}
</code></pre>
<p><code>ExtraFieldExtractor</code> 的 <code>extract</code> 方法中，循环 <code>names</code> 去<code>carrier</code> 里找，然后构造<code>Extra</code> 数据放入 <code>delegate</code> 执行 <code>extract</code> 方法后的结果中。</p>
<pre class="prettyprint"><code class="language-java">static final class ExtraFieldExtractor&lt;C, K&gt; implements Extractor&lt;C&gt; {
  final Extractor&lt;C&gt; delegate;
  final Propagation.Getter&lt;C, K&gt; getter;
  final Map&lt;String, K&gt; names;

  ExtraFieldExtractor(Extractor&lt;C&gt; delegate, Getter&lt;C, K&gt; getter, Map&lt;String, K&gt; names) {
    this.delegate = delegate;
    this.getter = getter;
    this.names = names;
  }

  @Override public TraceContextOrSamplingFlags extract(C carrier) {
    TraceContextOrSamplingFlags result = delegate.extract(carrier);

    Extra extra = null;
    for (Map.Entry&lt;String, K&gt; field : names.entrySet()) {
      String maybeValue = getter.get(carrier, field.getValue());
      if (maybeValue == null) continue;
      if (extra == null) {
        extra = new One();
      } else if (extra instanceof One) {
        One one = (One) extra;
        extra = new Many();
        extra.put(one.name, one.value);
      }
      extra.put(field.getKey(), maybeValue);
    }
    if (extra == null) return result;
    return result.toBuilder().addExtra(extra).build();
  }
}
</code></pre>
<div class="nav-next">
<p><strong>Next:</strong> <a href="../../monitoring-tracing/zipkin/recorder.html">Recorder</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../../monitoring-tracing/zipkin/propagation.html#propagation" class="header">Propagation</a>
  <ul>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#tracecontext" class="header">TraceContext</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#traceidcontext" class="header">TraceIdContext</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#tracecontextorsamplingflags" class="header">TraceContextOrSamplingFlags</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#currenttracecontext" class="header">CurrentTraceContext</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#threadlocalspan" class="header">ThreadLocalSpan</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#threadcontextcurrenttracecontext" class="header">ThreadContextCurrentTraceContext</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#跨进程传播" class="header">跨进程传播</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#propagation" class="header">Propagation</a></li>
    <li><a href="../../monitoring-tracing/zipkin/propagation.html#extrafieldpropagation" class="header">ExtraFieldPropagation</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2018</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '1.0', '')});</script>


</html>
