<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    <title>infilos | 正则表达式入门 </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"正则表达式入门","path":"reading/RD03-Compile/Recent-Articles/What-is-RE.html","support":{"link_url":"https://github.com/infilos/infilos.github.io/issues/new","link_text":"Raise an Issue on Github.","text":"Didn't find what you are looking for or find some errors? <br /> Try searching again on the left menu or","navigation":true,"navigation_label":"SUPPORT/FEEDBACK"}},"data":{"navigation":{"logo":{"text":"Infilos","type":"link","path":"index.html"},"main":[{"text":"Welcome","type":"link","path":"index.html"},{"text":"READING","type":"label"},{"text":"Operating System","type":"link","path":"reading/RD01-OS/index.html","children":[{"text":"现代操作系统","type":"link","path":"reading/RD01-OS/Modern-Operating-Systems/contents.html"}]},{"text":"Virtual\tMachine","type":"link","path":"reading/RD02-VM/index.html","children":[{"text":"深入理解 JVM","type":"link","path":"reading/RD02-VM/Dive-Into-Jvm/contents.html"}]},{"text":"Compile System","type":"link","path":"reading/RD03-Compile/index.html","children":[{"text":"相关文章","type":"link","path":"reading/RD03-Compile/Recent-Articles/content.html"}]},{"text":"Java Language","type":"link","path":"reading/RD04-Java/index.html","children":[{"text":"设计模式","type":"link","path":"reading/RD04-Java/Design-Patterns/content.html"}]},{"text":"Scala Language","type":"link","path":"reading/RD05-Scala/index.html","children":[{"text":"相关文章","type":"link","path":"reading/RD05-Scala/Recent-Articles/content.html"}]},{"text":"Concurrent","type":"link","path":"reading/RD06-Concurrent/index.html","children":[{"text":"深入并行编程","type":"link","path":"reading/RD06-Concurrent/Parallel-Programming/content.html"},{"text":"七并发模型","type":"link","path":"reading/RD06-Concurrent/Concurrency-Model/content.html"},{"text":"Java 内存模型","type":"link","path":"reading/RD06-Concurrent/Java-Memory-Model/content.html"},{"text":"Java 并发实战","type":"link","path":"reading/RD06-Concurrent/Java-Con-Practice/content.html"}]},{"text":"Networking","type":"link","path":"reading/RD07-Networking/index.html"},{"text":"Distribute System","type":"link","path":"reading/RD08-Distribute/index.html"},{"text":"Storage System","type":"link","path":"reading/RD09-Storage/index.html"},{"text":"Message System","type":"link","path":"reading/RD10-Messages/index.html"},{"text":"Realtime Processing","type":"link","path":"reading/RD11-Realtime/index.html"},{"text":"Monitoring/Tracing","type":"link","path":"reading/RD12-Monitoring/index.html"},{"text":"Architecture Pattern","type":"link","path":"reading/RD13-Architecture/index.html"},{"text":"User Interface","type":"link","path":"reading/RD14-UI/index.html"},{"text":"Dev Management","type":"link","path":"reading/RD15-Management/index.html"},{"text":"Resources","type":"link","path":"reading/RD99-Resources/index.html"},{"text":"RESEARCH","type":"label"},{"text":"Unified UDF Modeling","type":"link","path":"research/RS01-Unified-UDF/index.html"},{"text":"REFERENCE","type":"label"},{"text":"Infilow Reference","type":"link","path":"http://infilow.infilos.com/"},{"text":"Parboiled Reference","type":"link","path":"reference/RF04-Parboiled/index.html"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/images/favicon.ico","google_analytics":"UA-123062585-1","support":{"link_url":"https://github.com/infilos/infilos.github.io/issues/new","link_text":"Raise an Issue on Github.","text":"Didn't find what you are looking for or find some errors? <br /> Try searching again on the left menu or","navigation":true,"navigation_label":"SUPPORT/FEEDBACK"}}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Infilos</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span class>SUPPORT/FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a class href="https://github.com/infilos/infilos.github.io/issues/new" target="_blank"><span>Raise an Issue on Github.</span></a></li></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h1><p><a href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a>的学习整理，点击标题链接查看原文。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果要查找一篇引文小说中的“hi”，可以使用正则表达式<code>hi</code>，或者使用忽略大小写的选项，以同时能够匹配到<code>hi,HI,Hi,hI</code>这四种情况的任意一种。但是如果“hi”包含在一个单词中，比如“history，him”等，如果需要精确查找“hi”这个单词时，则需要使用<code>\bhi\b</code>。</p>
<p><code>\b</code>是正则表达式中规定的特殊字符，或称为元字符，表示单词的分界处。但是引文单词通常是由空格、换行、标点符号分割，但是<code>\b</code>并不能匹配这些，它只匹配一个位置。</p>
<p>如果要找的是“hi”后面不远处还有一个“Lucy”，可以使用<code>\bhi\b.*\bLucy\b</code>。</p>
<p>这里的<code>.</code>符号是另一个元字符，用于匹配除换行符意外的任意字符。<code>*</code>同样是元字符，它代表的是数量，它表示<code>*</code>前面的内容可以连续重复使用任意次，以使整个表达式得到匹配。因此，<code>.*</code>连在一起，表示任意数量的不包含换行的字符。现在，<code>\bhi\b.*\bLucy\b</code>的意思就很明显了：先是单词“hi”，然后是任意个任意字符（不包括换行），最后是“Lucy”这个单词。</p>
<p>同时使用多个元字符，可以构造出强大的表达式，比如<code>0\d\d-\d\d\d\d\d\d\d\d</code>，用于匹配一个字符串：以0开头，然后是两个数字，一个连字号“-”，后跟8个数字，也就是中国的电话号码。</p>
<p>这里的<code>\d</code>是另外一个元字符，匹配一位数字，而“-”并不是元字符，它只匹配本身。同时上面的例子可以简写成<code>0\d{2}-\d{8}</code>，<code>\d</code>后跟的<code>{8}</code>表示该<code>\d</code>必须重复的次数。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>上面已经提到了几个元字符：<code>\b, ., *, \d</code>，另外<code>\s</code>匹配任意的空白符，包括空格，制表(Tab)，换行，中文全角空格等。</p>
<p>另一些例子：</p>
<p><code>\ba\w*\b</code>匹配以字母“a”开头的单词：首先是一个单词的开始处<code>\b</code>，然后是字母“a”，然后是任意数量的字母或数字<code>\w*</code>，最后是单词的结尾<code>\b</code>。</p>
<p><code>\d+</code>匹配一个或更多连续的数字。<code>+</code>和<code>*</code>是类似的元字符，不同在于<code>*</code>重复任意次(可以是0次)，而<code>+</code>重复1次或更多次。</p>
<p><code>\b\w{6}\b</code>匹配6个字母的单词。</p>
<p>常用的元字符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">代码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">匹配字母、数字、下划线、汉字</td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">匹配任意空白字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">匹配数字</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">匹配字符串的结束</td>
</tr>
</tbody>
</table>
<p>元字符<code>^</code>和<code>$</code>都是匹配一个位置，这和<code>\b</code>有点类似。其中，<code>^</code>用于匹配要查找的字符串的开头，<code>$</code>匹配结尾。这在验证输入时非常有用，比如验证QQ必须是5到12位的数字时：<code>^\d{5,12}$</code>。</p>
<p><code>{5，12}</code>表示重复的次数，最少不能低于5次，最多不能超过12次。</p>
<p>因为同时使用了<code>^</code>和<code>$</code>，所以输入的整个字符串都要和<code>\d{5,12}</code>来匹配，也就是说整个输入必须是5到12个数字。</p>
<p>和忽略大小写的选项类似，有些正则工具还有一个处理多行的选项。如果开启该选项，则<code>^</code>和<code>$</code>的意义就变成了：匹配行的开始和结尾处。</p>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>如果想要匹配元字符本省，比如查找“.”或者“<em>”字符，需要使用反斜杠“\”进行转义，比如<code>\.</code>或`</em><code>，</code>\`用于匹配“\”字符本身。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>像上面提到的一些重复方式：<code>*</code>，<code>+</code>，<code>{2}</code>，<code>{5，12}</code>，下面是所有的重复限定符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">代码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">重复0次或更多次</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">重复1次或更多次</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">重复1次或0次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n}</code></td>
<td style="text-align:left">重复n次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}</code></td>
<td style="text-align:left">重复n次或更多次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,m}</code></td>
<td style="text-align:left">重复n到m次</td>
</tr>
</tbody>
</table>
<p><code>Windows\d+</code>匹配“Windows”后面跟一个或多个数字。
<code>^\w+</code>匹配一行的第一个单词。</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>有时候需要查找不属于某个简单定义的字符类的字符。可以使用反义。</p>
<p>常用的反义代码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">代码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">匹配任意不是字母、数字、下划线、汉字的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">匹配任意非数字的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\B</code></td>
<td style="text-align:left">匹配不是单词开头或结尾的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>[^x]</code></td>
<td style="text-align:left">匹配除了“x”以外的任意字符</td>
</tr>
<tr>
<td style="text-align:left"><code>[^aeiou]</code></td>
<td style="text-align:left">匹配除了“aeiou”几个字母之外的任意字符</td>
</tr>
</tbody>
</table>
<p><code>\S+</code>匹配不包含空白符的字符串。
<code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以“a”开头的字符串。</p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个自表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其他程序中做进一步的处理。默认情况下，每个分组会自动获取一个组号，规则是：从左到右，以分组的坐括号为组号，依次为1，2，3..递增。</p>
<p><strong>后向引用</strong> 用于重复搜索前面某个分组匹配的文本。比如，<code>\1</code>代表分组1匹配的文本。</p>
<p><code>\b(\w+)\b\s+\1\b</code>可以用来匹配重复的单词，像“go go”或“kitty kitty”。这个表达式首先是一个单词，也就是，单词开始处和结尾处之间的多余一个的字母或数字(<code>\b(\w+)\b</code>)，这个单词会被捕获到编号为1的分组中，然后是一个或多个空白符，最后是 分组1中捕获的内容(也就是前面捕获的那个单词)(<code>\1</code>)。</p>
<p>即：匹配一个单词后将它放入一个编号为1的分组，间隔一个或多个空白符后，通过<code>\1</code>的内容再次进行匹配后续的内容，以匹配像“go go”这样的字符串。</p>
<p>同时也可以自己指定自表达式的 <strong>组名</strong> 。通过尖括号或者单引号“’”指定：<code>?&lt;Word&gt;\w+</code>或<code>?&#39;Word&#39;\w+</code>，把<code>\w+</code>的组号指定为“Word”。要反向引用这个分组捕获的内容，可以使用<code>\k&lt;Word&gt;</code>，所以上一个例子可以改写为<code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code>。</p>
<p>小括号还有一些其他特定用途，常见的分组语法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">捕获</td>
<td style="text-align:left">(exp)</td>
<td style="text-align:left">匹配exp，并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td style="text-align:left">捕获</td>
<td style="text-align:left">(?<name>exp)</name></td>
<td style="text-align:left">匹配exp，并捕获文本到名称为name的组里，也可以改写成(?’name’exp)</td>
</tr>
<tr>
<td style="text-align:left">捕获</td>
<td style="text-align:left">(?:exp)</td>
<td style="text-align:left">匹配exp，不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td style="text-align:left">零宽断言</td>
<td style="text-align:left">(?=exp)</td>
<td style="text-align:left">匹配exp前面的位置</td>
</tr>
<tr>
<td style="text-align:left">零宽断言</td>
<td style="text-align:left">(?&lt;=exp)</td>
<td style="text-align:left">匹配exp后面的位置</td>
</tr>
<tr>
<td style="text-align:left">零宽断言</td>
<td style="text-align:left">(?!exp)</td>
<td style="text-align:left">匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td style="text-align:left">零宽断言</td>
<td style="text-align:left">(?&lt;!exp)</td>
<td style="text-align:left">匹配前面不是exp的位置</td>
</tr>
<tr>
<td style="text-align:left">注释</td>
<td style="text-align:left">(?#comment)</td>
<td style="text-align:left">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<p>已经讨论过前两种语法，第三个<code>(?:exp)</code>不会改变正则表达式的处理方式，只是这样的组匹配的内容：不会像前两种那样被捕获到某个组里，也不会拥有组号。</p>
<h2 id="领宽断言"><a href="#领宽断言" class="headerlink" title="领宽断言"></a>领宽断言</h2><p>上面的图表中领宽断言部分，它们像<code>\b</code>、<code>^</code>、<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件，即断言，因此也称为 <strong>零宽断言</strong> 。</p>
<p><code>(?=exp)</code>也叫 <strong>零宽度正预测先行断言</strong> ，它 断言自身出现的位置后面部分能匹配表达式exp。比如<code>\b\w+(?=ing\b)</code>，匹配以”ing“结尾的单词的前面部分(即除了ing以外的部分)，用它来查找”I’m singing while you’re dancing.“时会匹配到”sing“和”danc“。</p>
<p><code>(?&lt;=exp)</code>也叫 <strong>零宽度后回顾后发断言</strong> ，它 断言自身出现的位置的前面部分能匹配exp。比如<code>(?&lt;=\bre)\w+\b</code>会匹配：以”re“开头的单词的后半部分(除了re以外的部分)，查找”reading a book“时会匹配到”ading“。</p>
<p>如果想要给一个很长的数字中没三位间加一个逗号(从右边加起)，可以这样查找需要在前面和里面需要添加逗号的部分：<code>((?&lt;=\d)\d{3})+\b</code>，查找1234567890时会得到234567890。</p>
<p>一个同时使用两种断言的例子：<code>(?&lt;=\s)\d(?=\s)</code>，匹配：以空白符间隔的数字，不包括这些空白符。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>前面讨论过如何查找 <strong>不是某个字符或不在某个字符串里</strong> 的字符串的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不像去匹配它时怎么办呢？比如，我们想要查找单词，它里面出现了字母q，但是q后面跟的不是u我们可以尝试这样：<code>\b\w*q[^u]\w*\b</code>，匹配一个包含字母q，而q后面跟的又不是u的单词。</p>
<p>但是如果多测试会发现，如果q是单词结尾的话，像”Iraq，Benq“，该表达式就是失效。这是因为<code>[^u]</code>总要匹配一个字符，所有如果q是单词结尾字符的话，后面的<code>[^u]</code>将会匹配后面的单词分割符，后面的<code>\w*\b</code>将会匹配下一个单词，于是<code>\b\w*q[^u]\w*\b</code>就能匹配整个”Iraq fighting“。<strong>负向领宽断言</strong> 能够解决这个问题，因为它只匹配一个位置，而不消费任何字符，因此可以使用<code>\b\w*q(?!u)\w*\b</code>。</p>
<p><strong>零宽度负预测先行断言</strong> <code>(?!exp)</code>，断言此位置的后面的位置不能匹配表达式exp。比如：<code>\d{3}(?!\d)</code>匹配三位数字，而且这个三位数字的后面不能是数字。<code>\b((?!abc)\w)+\b</code>匹配不包含连续字符串”abc“的单词。</p>
<p>同样，可以使用<code>(?&lt;!exp)</code>，零宽度负回顾后发断言 来断言此位置的前面不能匹配表达式exp。<code>(?&lt;![a-z])\d{7}</code>匹配前面不是小写字母的七位数字。</p>
<p>一个更复杂的例子：<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>，匹配包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如<code>&lt;b&gt;</code>)，然后是<code>.*</code>(任意字符串)，最后一个是后缀<code>(?=&lt;\/\1&gt;)</code>。注意后缀中的<code>\/\</code>是字符转义。<code>\1</code>则是一个反向引用，引用的正式捕获的第一组，前面的<code>(\w+)</code>匹配的内容，这样如果前缀定义的是<b>的话，后缀就是</b>了，整个表达式匹配的是<b>和</b>之间的内容(不包括前缀和后缀本身)。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>小括号的另一种用途是通过语法<code>(?#comment)</code>来包含注释，例如：<code>2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</code>。</p>
<p>要包含注释的话，最好启用”忽略模式中的空白符“选项。这样在编写表达式时能任意添加空格、Tab、换行，在使用时这些都会被忽略。启用该选项后，在#后面到这一行结束的所有文本都会被当成注释忽略掉。比如可以写成这样：</p>
<pre><code>(?&lt;=    # 断言要匹配的文本的前缀
  &lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)
  )       # 前缀结束
  .*      # 匹配任意文本
  (?=     # 断言要匹配的文本的后缀
  &lt;\/\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签
  )       # 后缀结束
</code></pre><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>如果表达式中包含重复限定符时，通常是(在使整个表达式能得到匹配的前提下)匹配尽可能多的字符。比如<code>a.*b</code>，它将会匹配，最长的以a开始，以b结束的字符串。如果用它搜索”aabab“将会匹配整个字符串。称为 <strong>贪婪匹配</strong> 。</p>
<p>有时需要 <strong>懒惰匹配</strong> ，也就是匹配尽可能少的字符。前面给出的限定符都能转化为懒惰模式，只要在前面加一个问号<code>?</code>。<code>.*?</code>表示匹配任意数量的重复，但是在能使整个表达式匹配成功的前提下使用尽量少的重复。再次搜索上面的字符串，将会得到aab和ab。</p>
<p>懒惰限定符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>*?</code></td>
<td style="text-align:left">重复任意次，但是尽可能少的重复</td>
</tr>
<tr>
<td style="text-align:left"><code>+?</code></td>
<td style="text-align:left">重复1次或更多次，但是尽可能少的重复</td>
</tr>
<tr>
<td style="text-align:left"><code>??</code></td>
<td style="text-align:left">重复0次或1次，但是尽可能少的重复</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,m}</code></td>
<td style="text-align:left">重复n到m次，但是尽可能少的重复</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}</code></td>
<td style="text-align:left">重复n次以上，但是尽可能少的重复</td>
</tr>
</tbody>
</table>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>已经介绍过忽略大小写、处理多行等，这些选项用来改变处理正则表达式的方式。</p>
<p>.Net中常用的正则表达式选项：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IgnoreCase(忽略大小写)</td>
<td style="text-align:left">匹配时不区分大小写</td>
</tr>
<tr>
<td style="text-align:left">Multiline(多行模式)</td>
<td style="text-align:left"><code>^</code>和<code>$</code>在行首和行尾匹配，而不是字符串的开头和结尾</td>
</tr>
<tr>
<td style="text-align:left">Singleline(单行模式)</td>
<td style="text-align:left">更改<code>.</code>的含义，使他与每个字符匹配，包括换行符<code>\n</code></td>
</tr>
<tr>
<td style="text-align:left">IgnorePatternWhitespace(忽略空白)</td>
<td style="text-align:left">忽略表达式中的非转义空白并启用由<code>#</code>标记的注释</td>
</tr>
<tr>
<td style="text-align:left">ExplicitCapture(显式捕获)</td>
<td style="text-align:left">仅捕获已被显式命名的组</td>
</tr>
</tbody>
</table>
<p>单行模式与多行模式并无关联，可以同时使用。</p>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>有时需要匹配像“(100 * (50 + 15))”这样嵌套的层次结构，使用<code>\(.+\)</code>则只会匹配到最左边的左括号和最右边的右括号之间的内容。这种格式如何进行配对呢？</p>
<p>为了避免<code>(</code>和<code>\(</code>的混淆，这里我们可以使用尖括号。</p>
<p>这里需要用到一下的语法结构：</p>
<ol>
<li><code>(?&#39;group&#39;)</code> 把捕获的内容命名为group，并压入堆栈</li>
<li><code>(?&#39;-group&#39;)</code> 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈原来为空，则本分组的匹配失败</li>
<li><code>(?(group)yes|no)</code> 如果堆栈上存在的名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>
<li><code>(?!)</code> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>
</ol>
<p>我们需要做的就是每碰到左括号，就在压入一个“Open”，每碰到一个右括号，就弹出一个，到最后就看看堆栈是否为空，如果不为空就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面的货最后面的一些字符)，尽量使整个表达式得到匹配。</p>
<pre><code>&lt;                         #最外层的左括号
[^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容
(
    (
        (?&apos;Open&apos;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot;
        [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容
    )+
    (
        (?&apos;-Open&apos;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot;
        [^&lt;&gt;]*        #匹配右括号后面不是括号的内容
    )+
)*
(?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦的&quot;Open&quot;；如果还有，则匹配失败

&gt;                         #最外层的右括号
</code></pre><p>平衡组的一个最常见的应用就是匹配HTML，下面这个例子可以匹配嵌套的“div”标签：<code>&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&#39;Open&#39;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&#39;-Open&#39;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;</code> 。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他尚未详细讨论的语法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\a</code></td>
<td style="text-align:left">报警字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">Tab制表符</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">竖向制表符</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">换页符</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">换行符</td>
</tr>
<tr>
<td style="text-align:left"><code>\e</code></td>
<td style="text-align:left">Escape</td>
</tr>
<tr>
<td style="text-align:left"><code>\0nn</code></td>
<td style="text-align:left">ASCII代码中八进制代码为nn的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\xnn</code></td>
<td style="text-align:left">ASCII代码中十六进制代码为nn的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\unnn</code></td>
<td style="text-align:left">Unicode代码中十六进制为nnnn的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\cN</code></td>
<td style="text-align:left">ASCII控制字符。比如\cC代表Ctrl+c</td>
</tr>
<tr>
<td style="text-align:left"><code>\A</code></td>
<td style="text-align:left">字符串开头，类似<code>^</code>，但不受处理多行选项的影响</td>
</tr>
<tr>
<td style="text-align:left"><code>\Z</code></td>
<td style="text-align:left">字符串结尾或行尾，不受多行处理选项的影响</td>
</tr>
<tr>
<td style="text-align:left"><code>\z</code></td>
<td style="text-align:left">字符串结尾，类似<code>$</code>，但不受处理多行选项的影响</td>
</tr>
<tr>
<td style="text-align:left"><code>\G</code></td>
<td style="text-align:left">当前搜索的开头</td>
</tr>
<tr>
<td style="text-align:left"><code>\p{name}</code></td>
<td style="text-align:left">Unicode中命名为name的字符类，例如<code>\p{IsGreek}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>(?&gt;exp)</code></td>
<td style="text-align:left">贪婪子表达式</td>
</tr>
<tr>
<td style="text-align:left"><code>(?&lt;x&gt;-&lt;y&gt;exp)</code></td>
<td style="text-align:left">平衡组</td>
</tr>
<tr>
<td style="text-align:left"><code>(?im-nsx:exp)</code></td>
<td style="text-align:left">在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td style="text-align:left"><code>(?im-nsx)</code></td>
<td style="text-align:left">为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td style="text-align:left">`(?(exp)yes</td>
<td style="text-align:left">no)`</td>
<td>把exp当做零宽正向先行断言，如果这个位置能够匹配，使用yes作为此组的表达式，否则使用no</td>
</tr>
<tr>
<td style="text-align:left"><code>(?(exp)yes)</code></td>
<td style="text-align:left">同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td style="text-align:left">`?(name)yes</td>
<td style="text-align:left">no)`</td>
<td>如果命名为name的组捕获到了内容，使用yes作为表达式，否则使用no</td>
</tr>
<tr>
<td style="text-align:left"><code>?(name)yes)</code></td>
<td style="text-align:left">同上，只是使用空表达式作为no</td>
</tr>
</tbody>
</table>
<h2 id="常用表达式-1"><a href="#常用表达式-1" class="headerlink" title="常用表达式 - 1"></a>常用表达式 - 1</h2><p>一些常用的正则表达式：</p>
<ol>
<li>验证用户名和密码，5到15位的大小写字母、数字、下划线：<code>^[a-zA-Z]\w{5,15}$</code></li>
<li>验证电话号码：<code>^(\d{3,4}-)\d{7,8}$</code></li>
<li>验证手机号码：<code>^1[3|4|5|7|8[0-9]\d{8}$</code></li>
<li>验证身份证号(15-18位)：<code>\d{14}[[0-9],[0-9xX]]</code></li>
<li>验证Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\w+([-.]\w+)*$</code></li>
<li>限定数字和26个字母：<code>^[A-Za-z0-9]+$</code></li>
<li>整数或者小数：<code>[0-9]+([.]{0,1}[0-9]+){0,1}</code></li>
<li>数字：<code>^[0-9]*$</code></li>
<li>N位数字：<code>^\d{n}$</code></li>
<li>至少N位数字：<code>^\d{n,}$</code></li>
<li>M到N位数字：<code>^\d{m,n}$</code></li>
<li>0或非0开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code></li>
<li>1到3位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code></li>
<li>非零正整数：<code>^\+?[1-9][0-9]*$</code></li>
<li>非零负整数：<code>^\-?[1-9][0-9]*$</code></li>
<li>长度为3的字符：<code>^.{3}$</code></li>
<li>26个英文字母：<code>^[A-Za-z]+$</code></li>
<li>包含<code>^%&amp;&#39;,;=?$\</code>等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></li>
<li>汉字：<code>^[\u4e00-\u9fa5]{0,}$</code></li>
<li>验证URL：<code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>验证一年的12个月：<code>^(0?[1-9]|1[0-2])$</code></li>
<li>验证31天：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>
<li>获取日期：<code>\d{4}[年|\-|\.]\d{1-12}[月|\-|\.]\d{1-31}?</code></li>
<li>双字节字符串：<code>[^\x00-\xff]</code></li>
<li>匹配空白行：<code>\n\s*\r</code></li>
<li>HTML标记：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*?/&gt;</code></li>
<li>首尾空白：<code>^\s*|\s*$</code></li>
<li>IP地址：<code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</code></li>
</ol>
<h2 id="常用表达式-2"><a href="#常用表达式-2" class="headerlink" title="常用表达式 - 2"></a>常用表达式 - 2</h2><ol>
<li>校验密码强度,8-10位大小写字母数字,不包含字符: <code>^(?=.*d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></li>
<li>校验中文,只能包含中文: <code>^[u4e00-u9fa5]{0,}$</code></li>
<li>校验数字 + 26个字母 + 下划线的组合: <code>^w+$</code></li>
<li>校验Email地址: <code>[w!#$%&amp;&#39;*+/=?^_</code>{|}~-]+(?:.[w!#$%&amp;’<em>+/=?^_`{|}~-]+)</em>@(?:<a href="?:[w-]*[w]">w</a>?.)+<a href="?:[w-]*[w]">w</a>?`</li>
<li>校验身份证号码,15或18位: <code>^[1-9]d{7}((0d)|(1[0-2]))(([0|1|2]d)|3[0-1])d{3}$</code> 或 <code>^[1-9]d{5}[1-9]d{3}((0d)|(1[0-2]))(([0|1|2]d)|3[0-1])d{3}([0-9]|X)$</code></li>
<li>校验日期,<code>yyyy-mm-dd</code>格式: <code>^[1-9]d{5}[1-9]d{3}((0d)|(1[0-2]))(([0|1|2]d)|3[0-1])d{3}([0-9]|X)$</code></li>
<li>校验金额,精确两位小数: <code>^[0-9]+(.[0-9]{2})?$</code></li>
<li>校验手机号,13/15/18开头: <code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])d{8}$</code></li>
<li>判断IE版本: <code>^.*MSIE [5-8](?:.[0-9]+)?(?!.*Trident/[5-9].0).*$</code></li>
<li>校验IP-v4地址: <code>b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)b</code></li>
<li>校验IP-v6地址: <code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></li>
<li>校验URL前缀,判断是<code>http</code>还是<code>https</code>: <code>if (!s.match(/^[a-zA-Z]+:///)) {     s = &#39;http://&#39; + s; }</code></li>
<li>提取URL连接: <code>^(f|ht){1}(tp|tps)://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?</code></li>
<li>检验文件路径和扩展名: <code>^([a-zA-Z]:|)([^]+)*[^/:*?&quot;&lt;&gt;|]+.txt(l)?$</code></li>
<li>提取<code>Color Hex Codes</code>: <code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></li>
<li>提取网页图片: <code>&lt; *[img][^&gt;]*[src] *= *[&quot;&#39;]{0,1}([^&quot;&#39; &gt;]*)</code></li>
<li>提取页面超链接: <code>(&lt;as*(?!.*brel=)[^&gt;]*)(href=&quot;https?://)((?!(?:(?:www.)?&#39;.implode(&#39;|(?:www.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></li>
<li>查找CSS属性: <code>^s*[a-zA-Z-]+s*[:]{1}s[a-zA-Z0-9s.#]+[;]{1}</code></li>
<li>抽取注释: <code>&lt;!--(.*?)--&gt;</code></li>
<li>匹配HTML标签属性: <code>&lt;/?w+((s+w+(s*=s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[^&#39;&quot;&gt;s]+))?)+s*|s*)/?&gt;</code></li>
</ol>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    
<script>
  if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123062585-1', 'auto');
    ga('send', 'pageview');
  }
</script>



    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
