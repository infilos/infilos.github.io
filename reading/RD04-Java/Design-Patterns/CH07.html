<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    <title>infilos | CH07-结构型-桥接 </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"CH07-结构型-桥接","path":"reading/RD04-Java/Design-Patterns/CH07.html","support":{"link_url":"https://github.com/infilos/infilos.github.io/issues/new","link_text":"Raise an Issue on Github.","text":"Didn't find what you are looking for or find some errors? <br /> Try searching again on the left menu or","navigation":true,"navigation_label":"SUPPORT/FEEDBACK"}},"data":{"navigation":{"logo":{"text":"Infilos","type":"link","path":"index.html"},"main":[{"text":"Welcome","type":"link","path":"index.html"},{"text":"READING","type":"label"},{"text":"Operating System","type":"link","path":"reading/RD01-OS/index.html","children":[{"text":"现代操作系统","type":"link","path":"reading/RD01-OS/Modern-Operating-Systems/contents.html"}]},{"text":"Virtual\tMachine","type":"link","path":"reading/RD02-VM/index.html","children":[{"text":"深入理解 JVM","type":"link","path":"reading/RD02-VM/Dive-Into-Jvm/contents.html"}]},{"text":"Compile System","type":"link","path":"reading/RD03-Compile/index.html","children":[{"text":"相关文章","type":"link","path":"reading/RD03-Compile/Recent-Articles/content.html"}]},{"text":"Java Language","type":"link","path":"reading/RD04-Java/index.html","children":[{"text":"设计模式","type":"link","path":"reading/RD04-Java/Design-Patterns/content.html"}]},{"text":"Scala Language","type":"link","path":"reading/RD05-Scala/index.html","children":[{"text":"相关文章","type":"link","path":"reading/RD05-Scala/Recent-Articles/content.html"}]},{"text":"Concurrent","type":"link","path":"reading/RD06-Concurrent/index.html","children":[{"text":"深入并行编程","type":"link","path":"reading/RD06-Concurrent/Parallel-Programming/content.html"},{"text":"七并发模型","type":"link","path":"reading/RD06-Concurrent/Concurrency-Model/content.html"},{"text":"Java 内存模型","type":"link","path":"reading/RD06-Concurrent/Java-Memory-Model/content.html"},{"text":"Java 并发实战","type":"link","path":"reading/RD06-Concurrent/Java-Con-Practice/content.html"}]},{"text":"Networking","type":"link","path":"reading/RD07-Networking/index.html"},{"text":"Distribute System","type":"link","path":"reading/RD08-Distribute/index.html"},{"text":"Storage System","type":"link","path":"reading/RD09-Storage/index.html"},{"text":"Message System","type":"link","path":"reading/RD10-Messages/index.html"},{"text":"Realtime Processing","type":"link","path":"reading/RD11-Realtime/index.html"},{"text":"Monitoring/Tracing","type":"link","path":"reading/RD12-Monitoring/index.html"},{"text":"Architecture Pattern","type":"link","path":"reading/RD13-Architecture/index.html"},{"text":"User Interface","type":"link","path":"reading/RD14-UI/index.html"},{"text":"Dev Management","type":"link","path":"reading/RD15-Management/index.html"},{"text":"Resources","type":"link","path":"reading/RD99-Resources/index.html"},{"text":"RESEARCH","type":"label"},{"text":"Unified UDF Modeling","type":"link","path":"research/RS01-Unified-UDF/index.html"},{"text":"REFERENCE","type":"label"},{"text":"Infilow Reference","type":"link","path":"http://infilow.infilos.com/"},{"text":"Parboiled Reference","type":"link","path":"reference/RF04-Parboiled/index.html"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/images/favicon.ico","google_analytics":"UA-123062585-1","support":{"link_url":"https://github.com/infilos/infilos.github.io/issues/new","link_text":"Raise an Issue on Github.","text":"Didn't find what you are looking for or find some errors? <br /> Try searching again on the left menu or","navigation":true,"navigation_label":"SUPPORT/FEEDBACK"}}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Infilos</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span class>SUPPORT/FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a class href="https://github.com/infilos/infilos.github.io/issues/new" target="_blank"><span>Raise an Issue on Github.</span></a></li></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="CH07-结构型-桥接"><a href="#CH07-结构型-桥接" class="headerlink" title="CH07-结构型-桥接"></a>CH07-结构型-桥接</h1><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>设想如果要绘制矩形、圆形、椭圆、正方形，至少需要四种形状类，但是如果绘制的图形具有不同的颜色，此时至少有以下两种设计方案：</p>
<ol>
<li>为每一种形状都提供一套各种颜色的版本</li>
<li>根据实际需要对形状和颜色进行组合</li>
</ol>
<p>对于有两个变化维度的系统，采用第二种方案进行设计则类的个数更少，系统扩展也更方便。方案二即为桥接模式，该模式将继承关系转换为关联关系，减少耦合和编码量。</p>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p><strong>桥接模式(Bridge Pattern)</strong>，将抽象部分与它的实现部分分离，使他们都可以独立变化。又称为<strong>柄体模式(Handle and Body)</strong>或<strong>接口模式(Interface)</strong>。</p>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>包含四种角色：</p>
<ul>
<li>Abstraction：抽象类</li>
<li>RefinedAbstraction：扩充抽象类</li>
<li>Implementor：实现类接口</li>
<li>ConcreteImplementor：具体实现类</li>
</ul>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><div align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134608.png" style="display:block;width:70%;" alt="NAME" align="center">
</div>

<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><div align="center">
<img src="https://infi-img.oss-cn-hangzhou.aliyuncs.com/img/20190220134632.png" style="display:block;width:70%;" alt="NAME" align="center">
</div>

<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</span></span>&#123;</span><br><span class="line">  Implementor * pImp = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">  Abstraction * pa = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line">  pa-&gt;operation();</span><br><span class="line">  </span><br><span class="line">  Abstraction * pb = <span class="keyword">new</span> RefinedAbstraction(<span class="keyword">new</span> ConcreteImplementorB());</span><br><span class="line">  pb-&gt;operation();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><p>理解桥接模式，重点需要理解<strong>如何将抽象化(Abstraction)和实现化(Implementation)解耦，使得二者可以独立的变化。</strong></p>
<ol>
<li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当做同样的实体对待，将对象的共同性质抽取出来形成类的过程即为抽象化；</li>
<li><strong>解耦</strong>：解耦就是将抽象化和实现化之间的耦合解脱开，或者将他们之间的强关联转换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的解耦，是指在一个软件系统的抽象化和实现化之间使用关联关系(组合、聚合)，而不是继承关系，从而使两者可以相互独立的变化，也就是桥接模式的动机。</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>如果需要开发一个跨平台的视频播放器，可以在不同操作系统平台上播放多种格式的视频文件，常见的视频格式包括 MPEG、RMVB、AVI、WMV 等。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则(一个类只有一个变化的原因)，复用性较差，而且多继承中类的个数非常庞大，桥接则是更好的方法。</li>
<li>提高了系统的可扩充性，在两个变化维度任意扩展一个维度，都不需要修改原有的系统。</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>要求正确识别出系统中两个独立变化的维度，使用范围有一定局限性。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多灵活性，避免在两个层次之间建立静态继承关系，通过桥接模式可以使他们在抽象层建立一个关联关系。</li>
<li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要独立扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和实现化角色需要独立变化，设计要求独立管理这两者。</li>
<li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
</ul>
<h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>适配器与桥接模式联用：</p>
<p>​    桥接模式和适配器模式用于设计的不同阶段。桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使他们可以进行分别变化；在初步设计完成后，当发现系统与已有类无法协同工作时，可以使用适配器模式。有时也需要在设计初期使用适配器模式，尤其是在那些涉及大量第三方应用接口的时候。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    
<script>
  if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123062585-1', 'auto');
    ga('send', 'pageview');
  }
</script>



    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
