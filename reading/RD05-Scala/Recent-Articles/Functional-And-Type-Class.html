<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    <title>infilos | 函数式与类型类 </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"函数式与类型类","path":"reading/RD05-Scala/Recent-Articles/Functional-And-Type-Class.html","support":{"link_url":"https://github.com/infilos/infilos.github.io/issues/new","link_text":"Raise an Issue on Github.","text":"Didn't find what you are looking for or find some errors? <br /> Try searching again on the left menu or","navigation":true,"navigation_label":"SUPPORT/FEEDBACK"}},"data":{"navigation":{"logo":{"text":"Infilos","type":"link","path":"index.html"},"main":[{"text":"Welcome","type":"link","path":"index.html"},{"text":"READING","type":"label"},{"text":"Operating System","type":"link","path":"reading/RD01-OS/index.html","children":[{"text":"现代操作系统","type":"link","path":"reading/RD01-OS/Modern-Operating-Systems/contents.html"}]},{"text":"Virtual\tMachine","type":"link","path":"reading/RD02-VM/index.html","children":[{"text":"深入理解 JVM","type":"link","path":"reading/RD02-VM/Dive-Into-Jvm/contents.html"}]},{"text":"Compile System","type":"link","path":"reading/RD03-Compile/index.html","children":[{"text":"相关文章","type":"link","path":"reading/RD03-Compile/Recent-Articles/content.html"}]},{"text":"Java Language","type":"link","path":"reading/RD04-Java/index.html","children":[{"text":"设计模式","type":"link","path":"reading/RD04-Java/Design-Patterns/content.html"}]},{"text":"Scala Language","type":"link","path":"reading/RD05-Scala/index.html","children":[{"text":"相关文章","type":"link","path":"reading/RD05-Scala/Recent-Articles/content.html"}]},{"text":"Concurrent","type":"link","path":"reading/RD06-Concurrent/index.html","children":[{"text":"深入并行编程","type":"link","path":"reading/RD06-Concurrent/Parallel-Programming/content.html"},{"text":"七并发模型","type":"link","path":"reading/RD06-Concurrent/Concurrency-Model/content.html"},{"text":"Java 内存模型","type":"link","path":"reading/RD06-Concurrent/Java-Memory-Model/content.html"},{"text":"Java 并发实战","type":"link","path":"reading/RD06-Concurrent/Java-Con-Practice/content.html"}]},{"text":"Networking","type":"link","path":"reading/RD07-Networking/index.html"},{"text":"Distribute System","type":"link","path":"reading/RD08-Distribute/index.html"},{"text":"Storage System","type":"link","path":"reading/RD09-Storage/index.html"},{"text":"Message System","type":"link","path":"reading/RD10-Messages/index.html"},{"text":"Realtime Processing","type":"link","path":"reading/RD11-Realtime/index.html"},{"text":"Monitoring/Tracing","type":"link","path":"reading/RD12-Monitoring/index.html"},{"text":"Architecture Pattern","type":"link","path":"reading/RD13-Architecture/index.html"},{"text":"User Interface","type":"link","path":"reading/RD14-UI/index.html"},{"text":"Dev Management","type":"link","path":"reading/RD15-Management/index.html"},{"text":"Resources","type":"link","path":"reading/RD99-Resources/index.html"},{"text":"RESEARCH","type":"label"},{"text":"Unified UDF Modeling","type":"link","path":"research/RS01-Unified-UDF/index.html"},{"text":"REFERENCE","type":"label"},{"text":"Infilow Reference","type":"link","path":"http://infilow.infilos.com/"},{"text":"Parboiled Reference","type":"link","path":"reference/RF04-Parboiled/index.html"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/images/favicon.ico","google_analytics":"UA-123062585-1","support":{"link_url":"https://github.com/infilos/infilos.github.io/issues/new","link_text":"Raise an Issue on Github.","text":"Didn't find what you are looking for or find some errors? <br /> Try searching again on the left menu or","navigation":true,"navigation_label":"SUPPORT/FEEDBACK"}}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Infilos</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span class>SUPPORT/FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a class href="https://github.com/infilos/infilos.github.io/issues/new" target="_blank"><span>Raise an Issue on Github.</span></a></li></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="函数式与类型类"><a href="#函数式与类型类" class="headerlink" title="函数式与类型类"></a>函数式与类型类</h1><p><a href="https://alexn.org/blog/2012/11/02/scala-functional-programming-type-classes.html" target="_blank" rel="noopener">翻译自原文：On Scala, Functional Programming and Type-Classes</a></p>
<p>我曾经在 Coursera 上追随一个名为“ <a href="https://www.coursera.org/course/progfun" target="_blank" rel="noopener">Functional Programming Principles in Scala</a>”的精彩课程，该课程由 Martin Odersky(Scala 作者) 执教。这并不是我第一次遇到 Scala，因为我已经把它用在了日常工作当中。与此同时，我感觉需要找一个 Javascript 语言的替代者，因为优秀的 ClojureScript，我也开始了对 Clojure 的学习。</p>
<p>我对这两种语言都非常喜欢，真的说不上来更喜欢哪一个。这篇文档代表了我使用 Scala 的(菜鸟)经验，完全的瞎扯，或者你可以称它为“一个傻瓜的精神自慰”。</p>
<h2 id="1-函数式编程的双赢"><a href="#1-函数式编程的双赢" class="headerlink" title="1. 函数式编程的双赢"></a>1. 函数式编程的双赢</h2><p>它并非银弹，但整体来说非常棒。你真的有必要经历一次，同时撇开那些通过多年的必要技能而建立起的成见和偏见。学生学习起函数式编程会相对容易，他们并无任何经验，否则学习的过程将会很痛苦。</p>
<p>但在过去的 20 万年里我们进化的并不多，所以我们的大脑总是能在那些吸引我们内在兽性(inner-animal)的地方找到乐趣，对繁衍、吃饭、睡觉和躲避野兽感兴趣。学习是一种乐趣，但对于陌生的领域并非如此，因此如果你已经开始，那就要坚持下去。</p>
<p>首先我们需要一些对于函数式编程的定义：</p>
<ul>
<li>通过“引用透明”对函数求值来处理计算；(引用透明：函数的行为类似数学函数，相同的输入总会得到相同的结果)</li>
<li>一个计算的最终输出是对输入的多次转换结果的组合，而非通过那些构建可变状态的方式；</li>
</ul>
<p>一个函数式编程语言：</p>
<ul>
<li>将函数当做“一类(first-class)对象”，这表示处理高阶函数不但是可能的，而且是很以很舒服的方式；</li>
<li>为你提供用于组合函数与类型的工具。</li>
</ul>
<p>根据定义，像 Ruby、Javascript 这些也可以被认为是像样的函数式语言。然而我还要加几条：</p>
<ul>
<li>拥有丰富的不可变、持久化数据结构；</li>
<li>提供有效的处理“<a href="http://en.wikipedia.org/wiki/Expression_problem" target="_blank" rel="noopener">expression problem</a>”的类型系统。Rich Hickey 称之为“<em>polymorphism a la carte</em>”</li>
</ul>
<p>你也可以指定所有的副作用(side-effect)必须通过一元(monadic)类型来建模，不过这有点太清规戒律的意思(IMHO)，因为只有一种符合主流的语言 - Haskell。</p>
<h2 id="2-Scala-是一个函数式语言吗"><a href="#2-Scala-是一个函数式语言吗" class="headerlink" title="2. Scala 是一个函数式语言吗"></a>2. Scala 是一个函数式语言吗</h2><p>当然是。你只需要追随上面我提到的 Coursera 上的精彩<a href="https://www.coursera.org/course/progfun" target="_blank" rel="noopener">课程</a>、完成作业，你就会意识到 Scala 真正是一个非常函数式的语言。该课程虽短，不过有后续计划。因此现在就行动吧….</p>
<h2 id="3-Polymorphism-A-la-Carte"><a href="#3-Polymorphism-A-la-Carte" class="headerlink" title="3. Polymorphism À la Carte"></a>3. Polymorphism À la Carte</h2><p>这是我从 Rich Hickey 那听来的名词，当他谈论到开放式类型系统(open type-system)，主要引用了 Clojure 的 Protocol 和 Haskell 的 Type-Class。</p>
<p>这些多态机制能够很好的解决表达式问题，这与我们已知的 Java、C++ 这些面向对象语言形成鲜明对比。</p>
<p>OOP 通常是一个封闭的类型系统(closed type-system)，特别是在静态语言中使用时。将一个新类添加到层级结构、添加新函数来操作整个层级结构、给接口添加新的抽象成员、使内置类型以某种方式运转，所有这些都难以处理。</p>
<p>Haskell 通过 <a href="http://en.wikipedia.org/wiki/Type_class" target="_blank" rel="noopener">Type Classes</a> 来处理。Clojure 通过  <a href="http://en.wikipedia.org/wiki/Multiple_dispatch" target="_blank" rel="noopener">Multi-Methods</a> 和 Protocol 来处理，Protocol 是动态的，相当于 动态类型系统(dynamic type-system)中的 type-class。</p>
<h2 id="4-Yes-Virginia，Scala-拥有-Type-Class"><a href="#4-Yes-Virginia，Scala-拥有-Type-Class" class="headerlink" title="4. Yes Virginia，Scala 拥有 Type-Class"></a>4. Yes Virginia，Scala 拥有 Type-Class</h2><p>那什么又是 type-class？类似于 Java 中的接口，除了你可以使任何现有类型遵循它而不用修改该类型的实现。</p>
<p>比如，我们想要一个泛型函数能够将事物加起来….比如一个<code>foldLeft()</code>或<code>sum()</code>，但是相较于如何 fold，你想要环境知道如何处理每个特殊的类型。</p>
<p>在 Java 或 C# 中这样做有很多问题：</p>
<ul>
<li>对于那些支持相加操作的类型，并没有为<code>+</code>定义接口，比如：Integer/BigInteger/BigDecimal/Float/String…</li>
<li>我们需要从一些”0”开始(你想要折叠的列表可能为空)</li>
</ul>
<p>或许你可以定义一个这样的类型类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanFold</span>[-<span class="type">T</span>, <span class="type">R</span>]</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(acc:<span class="type">R</span>, elem:<span class="type">T</span>): <span class="type">R</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是等等，这不就是一个类 Java 的接口吗？对，他就是。这就是 Scala 最棒的地方，Scala 中任何实例都是对象，任何类型(type)都是一个类(class)。</p>
<p>那又是什么让这个接口成为了一个 type-class？当然是因为“伴生对象中带有隐式参数的对象”(<a href="http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf" target="_blank" rel="noopener">Objects in combination with implicit parameters</a>)。我们看一下如何使用这些来实现<code>sum</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">A</span>, <span class="type">B</span>](list: <span class="type">Traversable</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> adder: <span class="type">CanFold</span>[<span class="type">A</span>, <span class="type">B</span>]): <span class="type">B</span> = </span><br><span class="line">  list.foldLeft(addr.zero)((acc,e) =&gt; adder.sum(acc,e))</span><br></pre></td></tr></table></figure>
<p>因此，如果 Scala 编译器能够在作用域中找到一个为 A 定义的 隐式<code>CanFold</code>，就会使用它生产一个 B。它的出色表现在多个级别：</p>
<ul>
<li>类型 A 的隐式定义建立在返回类型 B 之上</li>
<li>可以为任何你需要的类型定义一个<code>CanFold</code>，整数、字符串、列表等等等</li>
</ul>
<p>隐式定义是有范围的，因此需要导入。如果你需要一些类型的默认隐式定义(全局可见)，可以在<code>CanFold</code>特质的伴生对象中定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CanFold</span></span>&#123;</span><br><span class="line">  <span class="comment">// default implementation for integers</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanFoldInts</span> <span class="keyword">extends</span> <span class="title">CanFold</span>[<span class="type">Int</span>, <span class="type">Long</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(acc:<span class="type">Long</span>, e:<span class="type">Int</span>) = acc + e</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时则和预期一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notice how the result of summing Integers is a Long</span></span><br><span class="line">sum(<span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="type">Nil</span>)</span><br><span class="line"><span class="comment">//=&gt; Long = 6</span></span><br></pre></td></tr></table></figure>
<p>我不会骗你这些方式有多难学或者如何学，你最终会拉起头发，期盼这些都不再是问题的动态类型。然而你要分清 hard 和 complex 的区别，前者是相对的、主观上的，后者是绝对的、可观上的。</p>
<p>我们实现中的一个难题是如何为一个基本类型提供默认实现。这也是为什么在<code>CanFold[-T,R]</code>的定义中我们将类型参数 T 设为逆变(<em>contravariant</em>)。逆变性代表的意思是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">B</span> inherits from <span class="type">A</span> (<span class="type">B</span> &lt;: <span class="type">A</span>), then</span><br><span class="line"><span class="type">CanFold</span>[<span class="type">A</span>, _] inherits from <span class="type">CanFold</span>[<span class="type">B</span>, _] (<span class="type">CanFold</span>[<span class="type">A</span>,_] &lt;: <span class="type">CanFold</span>[<span class="type">B</span>,_])</span><br></pre></td></tr></table></figure>
<p>这允许我们为任何 Traversable 定义一个 CanFold，该 CanFold 可以支持任何 Seq/Vector/List 等等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">CanFoldSeqs</span> <span class="keyword">extends</span> <span class="title">CanFold</span>[<span class="type">Traversable</span>[_], <span class="title">Traversable</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x:<span class="type">Travrsable</span>[_], y:<span class="type">Travsesable</span>[_]) = x ++ y</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Traversable</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以将任何类型的<code>Traversable</code>相加。问题是会在过程中丢失类型参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>) :: <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>) :: <span class="type">Nil</span>)</span><br><span class="line"><span class="comment">//=&gt; Traversable[Any] = List(1,2,3,4,6)</span></span><br></pre></td></tr></table></figure>
<p>为什么我会说它难的原因是在我把头发拉出来之后，不得不去<a href="http://stackoverflow.com/questions/13176697/problems-with-contravariance-in-scala" target="_blank" rel="noopener">StackOverFlow</a>请教怎么才能够返回一个<code>Traversable[Int]</code>。因此，你可以使用一个隐式的<code>def</code>替换之前的具体隐式对象，来帮助编译器识别容器中嵌入的类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">CanFoldSeqs</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">CanFold</span>[<span class="type">Traversable</span>[<span class="type">A</span>], <span class="type">Traversable</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x: <span class="type">Traversable</span>[<span class="type">A</span>], y:<span class="type">Traversable</span>[<span class="type">A</span>]) = x ++ y</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Traversable</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) :: <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>) :: <span class="type">Nil</span>)</span><br><span class="line"><span class="comment">//=&gt; Traversable[Int] = List(1,2,3,4,5)</span></span><br></pre></td></tr></table></figure>
<p>Implicit 比眼见的要灵活。显然编译器同样能够使用返回你需要的实例的函数，而不是具体的实例。作为一个旁注，我上面做的是很难的，甚至在 Haskell 中，因为子类化(sub-typing)是复杂的，但是 Clojure 中也很简单，因为你无需关注返回类型。</p>
<p><strong>NOTE：上面的实现并不严谨，可能会发生冲突。</strong></p>
<p>未完…</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    
<script>
  if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123062585-1', 'auto');
    ga('send', 'pageview');
  }
</script>



    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
